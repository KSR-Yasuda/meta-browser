From 47087cce2092beeb7d88351ed13f2531fa704ca0 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Mon, 24 Apr 2017 14:22:20 +0200
Subject: [PATCH 4/9] WIP - DBus remote backend

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 toolkit/components/remote/DBusRemoteService.cpp   | 150 ++++++++++++++++++
 toolkit/components/remote/DBusRemoteService.h     |  35 +++++
 toolkit/components/remote/moz.build               |  15 +-
 toolkit/components/remote/nsDBusRemoteService.cpp | 181 ----------------------
 toolkit/components/remote/nsDBusRemoteService.h   |  49 ------
 toolkit/components/remote/nsGTKRemoteService.cpp  |  21 ++-
 toolkit/components/remote/nsGTKRemoteService.h    |  13 +-
 toolkit/xre/nsAppRunner.cpp                       |  10 +-
 8 files changed, 224 insertions(+), 250 deletions(-)
 create mode 100644 toolkit/components/remote/DBusRemoteService.cpp
 create mode 100644 toolkit/components/remote/DBusRemoteService.h
 delete mode 100644 toolkit/components/remote/nsDBusRemoteService.cpp
 delete mode 100644 toolkit/components/remote/nsDBusRemoteService.h

diff --git a/toolkit/components/remote/DBusRemoteService.cpp b/toolkit/components/remote/DBusRemoteService.cpp
new file mode 100644
index 000000000000..4a3731a1dfaf
--- /dev/null
+++ b/toolkit/components/remote/DBusRemoteService.cpp
@@ -0,0 +1,150 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=2:tabstop=8:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBusRemoteService.h"
+
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+
+#include "mozilla/ModuleUtils.h"
+#include "nsIServiceManager.h"
+#include "nsIWeakReference.h"
+#include "nsIWidget.h"
+#include "nsIAppShellService.h"
+#include "nsAppShellCID.h"
+#include "nsPrintfCString.h"
+
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib-lowlevel.h>
+
+#include "mozilla/ipc/DBusMessageRefPtr.h"
+#include "mozilla/ipc/DBusPendingCallRefPtr.h"
+
+#define MOZILLA_TARGET              "org.mozilla"
+#define MOZILLA_REMOTE_OBJECT       "/org/mozilla/Firefox/Remote"
+
+const char* introspect_xml =
+"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
+"\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\";>\n"
+"<node>\n"
+"	<interface name=\"org.freedesktop.DBus.Introspectable\">\n"
+"		<method name=\"Introspect\">\n"
+"			<arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
+"		</method>\n"
+"	</interface>\n"
+"	<interface name=\"org.mozilla.firefox\">\n"
+"		<method name=\"Open\">\n"
+"			<arg name=\"url\" direction=\"out\" type=\"s\"/>\n"
+"		</method>\n"
+"	</interface>\n"
+"</node>\n";
+
+static void unregister(DBusConnection *connection, void *user_data)
+{
+}
+
+static DBusHandlerResult introspect(DBusConnection *conn, DBusMessage *msg)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(msg);
+	if (!reply)
+		return DBUS_HANDLER_RESULT_NEED_MEMORY;
+
+	dbus_message_append_args(reply,
+			DBUS_TYPE_STRING, &introspect_xml,
+			DBUS_TYPE_INVALID);
+
+	dbus_connection_send(conn, reply, NULL);
+	dbus_message_unref(reply);
+
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static DBusHandlerResult Open(DBusConnection *conn, DBusMessage *msg)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(msg);
+	if (!reply)
+		return DBUS_HANDLER_RESULT_NEED_MEMORY;
+
+	dbus_message_append_args(reply,
+			DBUS_TYPE_STRING, &introspect_xml,
+			DBUS_TYPE_INVALID);
+
+	dbus_connection_send(conn, reply, NULL);
+	dbus_message_unref(reply);
+
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static DBusHandlerResult message_handler(DBusConnection *conn,
+				DBusMessage *msg, void *user_data)
+{
+	const char *method = dbus_message_get_member(msg);
+	const char *iface = dbus_message_get_interface(msg);
+
+	if ((strcmp("Introspect", method) == 0) &&
+		 (strcmp("org.freedesktop.DBus.Introspectable", iface) == 0)) {
+		return introspect(conn, msg);
+  }
+
+	if ((strcmp("Open", method) == 0) && 
+    (strcmp("org.mozilla.firefox", iface) == 0)) {
+    return Open(conn, msg);
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static DBusObjectPathVTable remoteHandlersTable = {
+	.unregister_function	= unregister,
+	.message_function	= message_handler,
+};
+
+bool
+DBusRemoteService::Connect(const char* aAppName, const char* aProfileName)
+{
+  mConnection = already_AddRefed<DBusConnection>(
+    dbus_bus_get(DBUS_BUS_SESSION, nullptr));
+  if (!mConnection)
+    return NS_ERROR_FAILURE;
+
+  dbus_connection_set_exit_on_disconnect(mConnection, false);
+
+  nsAutoCString interfaceName;
+  interfaceName = nsPrintfCString("org.mozilla.%s.%s", aAppName, aProfileName);
+
+  int ret = dbus_bus_request_name(mConnection, interfaceName.get(),
+                                  DBUS_NAME_FLAG_DO_NOT_QUEUE, nullptr);
+  // The interface is already owned - there is another application/profile
+  // instance already running.
+  if (ret == -1) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+    return NS_ERROR_FAILURE;
+  }
+
+  if (!dbus_connection_register_object_path(mConnection, MOZILLA_REMOTE_OBJECT,
+                                            &remoteHandlersTable, nullptr)) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+DBusRemoteService::Disconnect()
+{
+  if (mConnection) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+  }
+}
diff --git a/toolkit/components/remote/DBusRemoteService.h b/toolkit/components/remote/DBusRemoteService.h
new file mode 100644
index 000000000000..8b284f4219f2
--- /dev/null
+++ b/toolkit/components/remote/DBusRemoteService.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=2:tabstop=2:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __DBusRemoteService_h__
+#define __DBusRemoteService_h__
+
+#include "mozilla/Attributes.h"
+
+#ifdef MOZ_ENABLE_DBUS
+#include "mozilla/ipc/DBusConnectionRefPtr.h"
+#endif
+
+class DBusRemoteService
+{
+public:
+  DBusRemoteService()
+#ifdef MOZ_ENABLE_DBUS  
+    : mConnection(nullptr)
+#endif
+    {}
+
+private:
+  bool Connect(const char* aAppName, const char* aProfileName);
+  void Disconnect();
+
+#ifdef MOZ_ENABLE_DBUS
+  RefPtr<DBusConnection> mConnection;
+#endif
+};
+
+#endif // __nsDBusRemoteService_h__
diff --git a/toolkit/components/remote/moz.build b/toolkit/components/remote/moz.build
index ab9f3e2c2777..50b13b768fe1 100644
--- a/toolkit/components/remote/moz.build
+++ b/toolkit/components/remote/moz.build
@@ -10,18 +10,13 @@ XPIDL_SOURCES += [
 
 XPIDL_MODULE = 'toolkitremote'
 
-if CONFIG['MOZ_WAYLAND']:
-    SOURCES += [
-        'nsDBusRemoteService.cpp',
-    ]
-else:
+SOURCES += [
+    'nsXRemoteService.cpp',
+]
+if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     SOURCES += [
-        'nsXRemoteService.cpp',
+        'nsGTKRemoteService.cpp',
     ]
-    if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
-        SOURCES += [
-            'nsGTKRemoteService.cpp',
-        ]
 
 FINAL_LIBRARY = 'xul'
 
diff --git a/toolkit/components/remote/nsDBusRemoteService.cpp b/toolkit/components/remote/nsDBusRemoteService.cpp
deleted file mode 100644
index 860efe0150ce..000000000000
--- a/toolkit/components/remote/nsDBusRemoteService.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:expandtab:shiftwidth=2:tabstop=8:
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsGTKRemoteService.h"
-
-#include <gtk/gtk.h>
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-
-#include "nsIBaseWindow.h"
-#include "nsIDocShell.h"
-#include "nsPIDOMWindow.h"
-#include "mozilla/ModuleUtils.h"
-#include "nsIServiceManager.h"
-#include "nsIWeakReference.h"
-#include "nsIWidget.h"
-#include "nsIAppShellService.h"
-#include "nsAppShellCID.h"
-
-#include "nsCOMPtr.h"
-
-#include "nsGTKToolkit.h"
-
-NS_IMPL_ISUPPORTS(nsGTKRemoteService,
-                  nsIRemoteService,
-                  nsIObserver)
-
-NS_IMETHODIMP
-nsGTKRemoteService::Startup(const char* aAppName, const char* aProfileName)
-{
-  NS_ASSERTION(aAppName, "Don't pass a null appname!");
-  sRemoteImplementation = this;
-
-  if (mServerWindow) return NS_ERROR_ALREADY_INITIALIZED;
-
-  XRemoteBaseStartup(aAppName, aProfileName);
-
-  mServerWindow = gtk_invisible_new();
-  gtk_widget_realize(mServerWindow);
-  HandleCommandsFor(mServerWindow, nullptr);
-
-  for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
-    HandleCommandsFor(iter.Key(), iter.UserData());
-  }
-
-  return NS_OK;
-}
-
-static nsIWidget* GetMainWidget(nsPIDOMWindowInner* aWindow)
-{
-  // get the native window for this instance
-  nsCOMPtr<nsIBaseWindow> baseWindow
-    (do_QueryInterface(aWindow->GetDocShell()));
-  NS_ENSURE_TRUE(baseWindow, nullptr);
-
-  nsCOMPtr<nsIWidget> mainWidget;
-  baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
-  return mainWidget;
-}
-
-NS_IMETHODIMP
-nsGTKRemoteService::RegisterWindow(mozIDOMWindow* aWindow)
-{
-  nsIWidget* mainWidget = GetMainWidget(nsPIDOMWindowInner::From(aWindow));
-  NS_ENSURE_TRUE(mainWidget, NS_ERROR_FAILURE);
-
-  GtkWidget* widget =
-    (GtkWidget*) mainWidget->GetNativeData(NS_NATIVE_SHELLWIDGET);
-  NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsIWeakReference> weak = do_GetWeakReference(aWindow);
-  NS_ENSURE_TRUE(weak, NS_ERROR_FAILURE);
-
-  mWindows.Put(widget, weak);
-
-  // If Startup() has already been called, immediately register this window.
-  if (mServerWindow) {
-    HandleCommandsFor(widget, weak);
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGTKRemoteService::Shutdown()
-{
-  if (!mServerWindow)
-    return NS_ERROR_NOT_INITIALIZED;
-
-  gtk_widget_destroy(mServerWindow);
-  mServerWindow = nullptr;
-  return NS_OK;
-}
-
-// Set desktop startup ID to the passed ID, if there is one, so that any created
-// windows get created with the right window manager metadata, and any windows
-// that get new tabs and are activated also get the right WM metadata.
-// The timestamp will be used if there is no desktop startup ID, or if we're
-// raising an existing window rather than showing a new window for the first time.
-void
-nsGTKRemoteService::SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
-                                                   uint32_t aTimestamp) {
-  nsGTKToolkit* toolkit = nsGTKToolkit::GetToolkit();
-  if (!toolkit)
-    return;
-
-  if (!aDesktopStartupID.IsEmpty()) {
-    toolkit->SetDesktopStartupID(aDesktopStartupID);
-  }
-
-  toolkit->SetFocusTimestamp(aTimestamp);
-}
-
-
-void
-nsGTKRemoteService::HandleCommandsFor(GtkWidget* widget,
-                                      nsIWeakReference* aWindow)
-{
-  g_signal_connect(G_OBJECT(widget), "property_notify_event",
-                   G_CALLBACK(HandlePropertyChange), aWindow);
-
-  gtk_widget_add_events(widget, GDK_PROPERTY_CHANGE_MASK);
-
-#if (MOZ_WIDGET_GTK == 2)
-  Window window = GDK_WINDOW_XWINDOW(widget->window);
-#else
-  Window window = gdk_x11_window_get_xid(gtk_widget_get_window(widget));
-#endif
-  nsXRemoteService::HandleCommandsFor(window);
-
-}
-
-gboolean
-nsGTKRemoteService::HandlePropertyChange(GtkWidget *aWidget,
-                                         GdkEventProperty *pevent,
-                                         nsIWeakReference *aThis)
-{
-  if (pevent->state == GDK_PROPERTY_NEW_VALUE) {
-    Atom changedAtom = gdk_x11_atom_to_xatom(pevent->atom);
-
-#if (MOZ_WIDGET_GTK == 2)
-    XID window = GDK_WINDOW_XWINDOW(pevent->window);
-#else
-    XID window = gdk_x11_window_get_xid(gtk_widget_get_window(aWidget));
-#endif
-    return HandleNewProperty(window,
-                             GDK_DISPLAY_XDISPLAY(gdk_display_get_default()),
-                             pevent->time, changedAtom, aThis);
-  }
-  return FALSE;
-}
-
-
-// {C0773E90-5799-4eff-AD03-3EBCD85624AC}
-#define NS_REMOTESERVICE_CID \
-  { 0xc0773e90, 0x5799, 0x4eff, { 0xad, 0x3, 0x3e, 0xbc, 0xd8, 0x56, 0x24, 0xac } }
-
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsGTKRemoteService)
-NS_DEFINE_NAMED_CID(NS_REMOTESERVICE_CID);
-
-static const mozilla::Module::CIDEntry kRemoteCIDs[] = {
-  { &kNS_REMOTESERVICE_CID, false, nullptr, nsGTKRemoteServiceConstructor },
-  { nullptr }
-};
-
-static const mozilla::Module::ContractIDEntry kRemoteContracts[] = {
-  { "@mozilla.org/toolkit/remote-service;1", &kNS_REMOTESERVICE_CID },
-  { nullptr }
-};
-
-static const mozilla::Module kRemoteModule = {
-  mozilla::Module::kVersion,
-  kRemoteCIDs,
-  kRemoteContracts
-};
-
-NSMODULE_DEFN(RemoteServiceModule) = &kRemoteModule;
diff --git a/toolkit/components/remote/nsDBusRemoteService.h b/toolkit/components/remote/nsDBusRemoteService.h
deleted file mode 100644
index 034a77a24c78..000000000000
--- a/toolkit/components/remote/nsDBusRemoteService.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:expandtab:shiftwidth=2:tabstop=2:
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __nsGTKRemoteService_h__
-#define __nsGTKRemoteService_h__
-
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include <gtk/gtk.h>
-
-#include "nsInterfaceHashtable.h"
-#include "nsXRemoteService.h"
-#include "mozilla/Attributes.h"
-
-class nsGTKRemoteService final : public nsXRemoteService
-{
-public:
-  // We will be a static singleton, so don't use the ordinary methods.
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIREMOTESERVICE
-
-
-  nsGTKRemoteService() :
-    mServerWindow(nullptr) { }
-
-private:
-  ~nsGTKRemoteService() { }
-
-  void HandleCommandsFor(GtkWidget* aWidget,
-                         nsIWeakReference* aWindow);
-
-
-  static gboolean HandlePropertyChange(GtkWidget *widget,
-                                       GdkEventProperty *event,
-                                       nsIWeakReference* aThis);
-
-
-  virtual void SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
-                                              uint32_t aTimestamp) override;
-
-  nsInterfaceHashtable<nsPtrHashKey<GtkWidget>, nsIWeakReference> mWindows;
-  GtkWidget* mServerWindow;  
-};
-
-#endif // __nsGTKRemoteService_h__
diff --git a/toolkit/components/remote/nsGTKRemoteService.cpp b/toolkit/components/remote/nsGTKRemoteService.cpp
index 860efe0150ce..e7f9914fcf50 100644
--- a/toolkit/components/remote/nsGTKRemoteService.cpp
+++ b/toolkit/components/remote/nsGTKRemoteService.cpp
@@ -37,14 +37,23 @@ nsGTKRemoteService::Startup(const char* aAppName, const char* aProfileName)
 
   if (mServerWindow) return NS_ERROR_ALREADY_INITIALIZED;
 
-  XRemoteBaseStartup(aAppName, aProfileName);
-
   mServerWindow = gtk_invisible_new();
   gtk_widget_realize(mServerWindow);
-  HandleCommandsFor(mServerWindow, nullptr);
 
-  for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
-    HandleCommandsFor(iter.Key(), iter.UserData());
+  mIsX11Display = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+#if defined(MOZ_WAYLAND) && defined(MOZ_ENABLE_DBUS)
+  if (!mIsX11Display) {
+    Connect(aAppName, aProfileName);
+  } else
+#endif
+  {
+    XRemoteBaseStartup(aAppName, aProfileName);
+
+    HandleCommandsFor(mServerWindow, nullptr);
+
+    for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
+      HandleCommandsFor(iter.Key(), iter.UserData());
+    }
   }
 
   return NS_OK;
@@ -78,7 +87,7 @@ nsGTKRemoteService::RegisterWindow(mozIDOMWindow* aWindow)
   mWindows.Put(widget, weak);
 
   // If Startup() has already been called, immediately register this window.
-  if (mServerWindow) {
+  if (mServerWindow && mIsX11Display) {
     HandleCommandsFor(widget, weak);
   }
 
diff --git a/toolkit/components/remote/nsGTKRemoteService.h b/toolkit/components/remote/nsGTKRemoteService.h
index 034a77a24c78..77fdd0088b50 100644
--- a/toolkit/components/remote/nsGTKRemoteService.h
+++ b/toolkit/components/remote/nsGTKRemoteService.h
@@ -15,8 +15,14 @@
 #include "nsInterfaceHashtable.h"
 #include "nsXRemoteService.h"
 #include "mozilla/Attributes.h"
-
-class nsGTKRemoteService final : public nsXRemoteService
+#if defined(MOZ_WAYLAND) && defined(MOZ_ENABLE_DBUS)
+#include "DBusRemoteService.h"
+#endif
+
+class nsGTKRemoteService final : public nsXRemoteService,
+#if defined(MOZ_WAYLAND) && defined(MOZ_ENABLE_DBUS)
+                                 public DBusRemoteService
+#endif
 {
 public:
   // We will be a static singleton, so don't use the ordinary methods.
@@ -43,7 +49,8 @@ private:
                                               uint32_t aTimestamp) override;
 
   nsInterfaceHashtable<nsPtrHashKey<GtkWidget>, nsIWeakReference> mWindows;
-  GtkWidget* mServerWindow;  
+  GtkWidget* mServerWindow;
+  bool       mIsX11Display;
 };
 
 #endif // __nsGTKRemoteService_h__
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index 81cd1371170f..cdec7dfa8418 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -246,6 +246,9 @@ nsString gAbsoluteArgv0Path;
 #include <pango/pangofc-fontmap.h>
 #endif
 #include <gtk/gtk.h>
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 #endif /* MOZ_X11 */
@@ -2889,16 +2892,21 @@ static const char* detectDisplay(void)
   } else if (backend) {
     if (strstr(backend, "x11"))
       tryX11 = true;
+#ifdef MOZ_WAYLAND
     if (strstr(backend, "wayland"))
       tryWayland = true;
+#endif
   }
 
   const char *display_name;
   if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
     return display_name;
-  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+  }
+#ifdef MOZ_WAYLAND
+  if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
     return display_name;
   }
+#endif
 
   PR_fprintf(PR_STDERR, "Error: GDK_BACKEND does not match available displays\n");
   return nullptr;
-- 
2.11.0


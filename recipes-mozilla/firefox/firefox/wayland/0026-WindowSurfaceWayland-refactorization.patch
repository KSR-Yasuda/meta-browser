From 25960218dcca87f1c2758bf71e70125ab688e335 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Mon, 10 Apr 2017 11:15:32 +0200
Subject: [PATCH 26/44] WindowSurfaceWayland refactorization

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 widget/gtk/WindowSurfaceWayland.cpp | 472 ++++++++++++++++++------------------
 widget/gtk/WindowSurfaceWayland.h   | 110 +++++----
 widget/gtk/moz.build                |   1 -
 widget/gtk/os-compatibility.c       | 201 ---------------
 widget/gtk/os-compatibility.h       |  54 -----
 5 files changed, 303 insertions(+), 535 deletions(-)
 delete mode 100644 widget/gtk/os-compatibility.c
 delete mode 100644 widget/gtk/os-compatibility.h

diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index cb973de2e1b9..c73dafc70108 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -5,16 +5,9 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /*
- * Derived from Weston project,
- * https://github.com/wayland-project/weston/blob/master/clients/simple-shm.c
- */
-/*
 TODO:
-moz-container -> display check
 X11CompositorWidget - update
 nsWindow::GetCompositorWidgetInitData
-GDK_WINDOWING_X11 - remove
-#ifdef MOZ_WAYLAND + display test
 - ensure we always draw to container
 - surface cleaning/realocation
 - can we redraw on allocate?
@@ -25,23 +18,25 @@ GDK_WINDOWING_X11 - remove
 - call wayland display/queue events right after attach&co?
 - optimization -> use Image bufer when update area is smaller that whole window
 - is bounds.x bounds.y non-zero??
-- buffer sync - can be undamaged part unsynced?
 - GdkWidnow - show/hide -> callback, get surface and frame callback
 - optimization - give backbuffer directly when requested whole area in Lock()
-- how big is rectangle owerlap in BackBufferWayland::CopyRectangle()?
+- how big is rectangle owerlap in WindowBackBuffer::CopyRectangle()?
 (firefox:15155): Gdk-WARNING **: Tried to map a popup with a non-top most parent
   - it was ok in X11
 - try to draw (first commit) when vblank comes like Gtk does, not when gecko calls it
+- why we can't draw directly to back-buffer? Why do we need the image buffer??
+
 */
 #include <assert.h>
 #include <poll.h>
 
 #include "WindowSurfaceWayland.h"
 
+#include "nsPrintfCString.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/Tools.h"
 #include "gfxPlatform.h"
-#include "os-compatibility.h"
+#include "mozcontainer.h"
 
 #include <gdk/gdkwayland.h>
 #include <sys/mman.h>
@@ -50,16 +45,122 @@ GDK_WINDOWING_X11 - remove
 namespace mozilla {
 namespace widget {
 
-bool                WindowSurfaceWayland::mIsAvailable;
-bool                WindowSurfaceWayland::mInitialized;
-gfx::SurfaceFormat  WindowSurfaceWayland::mFormat = gfx::SurfaceFormat::UNKNOWN;
-wl_shm*             WindowSurfaceWayland::mShm;
-wl_event_queue*     WindowSurfaceWayland::mQueue;
-GThread*            WindowSurfaceWayland::mThread;
-wl_display*         WindowSurfaceWayland::mDisplay;
+static WaylandDisplay *gWaylandDisplay = nullptr;
+
+void
+WaylandDisplayInit(wl_display *aDisplay)
+{
+    if (!gWaylandDisplay) {
+        gWaylandDisplay = new WaylandDisplay(aDisplay);
+    }
+}
+
+void
+WaylandDisplay::SetWaylandPixelFormat(uint32_t format)
+{
+  switch (format) {
+    case WL_SHM_FORMAT_ARGB8888:
+      mFormat = gfx::SurfaceFormat::B8G8R8A8;
+      break;
+    case WL_SHM_FORMAT_XRGB8888:
+      // TODO - We can use non-alpha formats when we need that
+    default:
+      break;
+  }
+}
+
+static void
+shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+{
+  auto interface = reinterpret_cast<WaylandDisplay *>(data);
+  interface->SetWaylandPixelFormat(format);
+ }
+
+struct wl_shm_listener shm_listener = {
+	shm_format
+};
+
+static void
+global_registry_handler(void *data, wl_registry *registry, uint32_t id,
+	                      const char *interface, uint32_t version)
+{
+  if (strcmp(interface, "wl_shm") == 0) {
+    auto interface = reinterpret_cast<WaylandDisplay *>(data);
+    auto shm = static_cast<wl_shm*>(
+        wl_registry_bind(registry, id, &wl_shm_interface, 1));
+    wl_proxy_set_queue((struct wl_proxy *)shm, interface->GetEventQueue());
+    wl_shm_add_listener(shm, &shm_listener, data);
+    interface->SetShm(shm);
+  }
+}
+
+static void
+global_registry_remover(void *data, wl_registry *registry, uint32_t id)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  global_registry_handler,
+  global_registry_remover
+};
+
+static gpointer
+WaylandDisplayLoop(gpointer data)
+{
+  wl_display *display = gWaylandDisplay->GetDisplay();
+  wl_event_queue *eventQueue = gWaylandDisplay->GetEventQueue();
+
+  struct pollfd fds;
+  fds.fd = wl_display_get_fd(display);
+  fds.events = POLLIN;
+
+  /* main loop */
+  while (1) {
+      while (wl_display_prepare_read_queue(display, eventQueue) < 0) {
+          wl_display_dispatch_queue_pending(display, eventQueue);
+      }
+      wl_display_flush(display);
+
+      int ret = poll(&fds, 1, -1);
+      if (ret == -1) {
+          wl_display_cancel_read(display);
+      }
+      wl_display_read_events(display);
+      wl_display_dispatch_queue_pending(display, eventQueue);
+  }
+
+  return nullptr;
+}
+
+WaylandDisplay::WaylandDisplay(wl_display *aDisplay)
+  : mDisplay(aDisplay)
+{
+  mEventQueue = wl_display_create_queue(mDisplay);
+
+  // wl_shm and wl_subcompositor are not provided by Gtk so we need
+  // to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);
+  wl_proxy_set_queue((struct wl_proxy *)registry, mEventQueue);
+  wl_registry_add_listener(registry, &registry_listener, this);
+
+  // We need two roundtrips here to get the registry info
+  wl_display_dispatch_queue(mDisplay, mEventQueue);
+  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+
+  // We must have a valid pixel format
+  MOZ_RELEASE_ASSERT(mFormat != gfx::SurfaceFormat::UNKNOWN,
+                     "We don't have any pixel format!");
+
+  mLoopThread = g_thread_new("WaylandDisplayLoop", WaylandDisplayLoop, this);
+}
+
+WaylandDisplay::~WaylandDisplay()
+{
+}
 
 ImageBuffer::ImageBuffer()
-  : mBufferData(nullptr)
+  : mImageData(nullptr)
   , mBufferAllocated(0)
   , mWidth(0)
   , mHeight(0)
@@ -68,8 +169,8 @@ ImageBuffer::ImageBuffer()
 
 ImageBuffer::~ImageBuffer()
 {
-  if (mBufferData)
-    free(mBufferData);
+  if (mImageData)
+    free(mImageData);
 }
 
 already_AddRefed<gfx::DrawTarget>
@@ -78,22 +179,15 @@ ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
   gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
   gfx::IntSize imageSize(bounds.XMost(), bounds.YMost());
 
-  // We use the same trick as nsShmImage::CreateDrawTarget() does:
-  // Due to bug 1205045, we must avoid making GTK calls off the main thread
-  // to query window size.
-  // Instead we just track the largest offset within the image we are
-  // drawing to and grow the image to accomodate it. Since usually
-  // the entire window is invalidated on the first paint to it,
-  // this should grow the image to the necessary size quickly without
-  // many intermediate reallocations.
+  //TODO -> widget->getBounds!!
   int newSize = imageSize.width * imageSize.height * BUFFER_BPP;
-  if (!mBufferData || mBufferAllocated < newSize) {
-    if (mBufferData) {
-      free(mBufferData);
+  if (!mImageData || mBufferAllocated < newSize) {
+    if (mImageData) {
+      free(mImageData);
     }
 
-    mBufferData = (unsigned char*)malloc(newSize);
-    if (!mBufferData)
+    mImageData = (unsigned char*)malloc(newSize);
+    if (!mImageData)
       return nullptr;
 
     mBufferAllocated = newSize;
@@ -102,35 +196,66 @@ ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
   mWidth = imageSize.width;
   mHeight = imageSize.height;
 
-  return gfxPlatform::CreateDrawTargetForData(mBufferData, imageSize,
-    BUFFER_BPP * mWidth, WindowSurfaceWayland::GetSurfaceFormat());
+  return gfxPlatform::CreateDrawTargetForData(mImageData, imageSize,
+    BUFFER_BPP * mWidth, gWaylandDisplay->GetSurfaceFormat());
 }
 
-bool BackBufferWayland::CreateShmPool(int aSize)
+int
+WaylandShmBuffer::CreateTemporaryFile(int aSize)
 {
-  mAllocatedSize = aSize;
+  const char* tmppath = getenv("XDG_RUNTIME_DIR");
+  MOZ_RELEASE_ASSERT(tmppath, "Missing XDG_RUNTIME_DIR env variable.");
+
+  nsPrintfCString tmpname("%s/weston-shared-XXXXXX", tmppath);
+
+  char* filename;
+  int fd = -1;
+
+  if (tmpname.GetMutableData(&filename)) {
+    	fd = mkstemp(filename);
+    	if (fd >= 0) {
+          int flags = fcntl(fd, F_GETFD);
+          if (flags >= 0) {
+              fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
+          }
+    	}
+  }
 
-  mShmPoolFd = os_create_anonymous_file(mAllocatedSize);
-  if (mShmPoolFd < 0)
-    return false;
+  if (fd >= 0) {
+      unlink(tmpname.get());
+  } else {
+      printf_stderr("Unable to create mapping file %s\n", filename);
+      MOZ_CRASH();
+  }
+
+#ifdef HAVE_POSIX_FALLOCATE
+	int ret = posix_fallocate(fd, 0, aSize);
+#else
+	int ret = ftruncate(fd, aSize);
+#endif
+  MOZ_RELEASE_ASSERT(ret == 0, "Mapping file allocation failed.");
+
+	return fd;
+}
 
-  mBufferData = mmap(nullptr, mAllocatedSize,
+WaylandShmBuffer::WaylandShmBuffer(int aSize)
+{
+  mAllocatedSize = aSize;
+
+  mShmPoolFd = CreateTemporaryFile(mAllocatedSize);
+  mImageData = mmap(nullptr, mAllocatedSize,
                      PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
-  if (mBufferData == MAP_FAILED) {
-    close(mShmPoolFd);
-    mShmPoolFd = 0;
-    return false;
-  }
+  MOZ_RELEASE_ASSERT(mImageData != MAP_FAILED,
+                     "Unable to map drawing surface!");
 
-  mShmPool = wl_shm_create_pool(WindowSurfaceWayland::GetShm(),
+  mShmPool = wl_shm_create_pool(gWaylandDisplay->GetShm(),
                                 mShmPoolFd, mAllocatedSize);
   wl_proxy_set_queue((struct wl_proxy *)mShmPool,
-                     WindowSurfaceWayland::GetQueue());
-
-  return true;
+                     gWaylandDisplay->GetEventQueue());
 }
 
-bool BackBufferWayland::ResizeShmPool(int aSize)
+bool
+WaylandShmBuffer::Resize(int aSize)
 {
   // We do size increase only
   if (aSize <= mAllocatedSize)
@@ -147,31 +272,28 @@ bool BackBufferWayland::ResizeShmPool(int aSize)
 
   wl_shm_pool_resize(mShmPool, aSize);
 
-  munmap(mBufferData, mAllocatedSize);
+  munmap(mImageData, mAllocatedSize);
 
-  mBufferData = mmap(nullptr, aSize,
+  mImageData = mmap(nullptr, aSize,
                      PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
-  if (mBufferData == MAP_FAILED)
+  if (mImageData == MAP_FAILED)
     return false;
 
   mAllocatedSize = aSize;
   return true;
 }
 
-void BackBufferWayland::ReleaseShmPool()
+WaylandShmBuffer::~WaylandShmBuffer()
 {
-  munmap(mBufferData, mAllocatedSize);
+  munmap(mImageData, mAllocatedSize);
   wl_shm_pool_destroy(mShmPool);
   close(mShmPoolFd);
-
-  mBufferData = nullptr;
-  mAllocatedSize = 0;
 }
 
 static void
 buffer_release(void *data, wl_buffer *buffer)
 {
-  auto surface = reinterpret_cast<BackBufferWayland*>(data);
+  auto surface = reinterpret_cast<WindowBackBuffer*>(data);
   surface->Detach();
 }
 
@@ -179,69 +301,62 @@ static const struct wl_buffer_listener buffer_listener = {
   buffer_release
 };
 
-void BackBufferWayland::CreateBuffer(int aWidth, int aHeight)
+void WindowBackBuffer::Create(int aWidth, int aHeight)
 {
-  mBuffer = wl_shm_pool_create_buffer(mShmPool, 0,
-                              			  aWidth, aHeight, aWidth*BUFFER_BPP,
-                              			  WL_SHM_FORMAT_ARGB8888);
-  wl_proxy_set_queue((struct wl_proxy *)mBuffer,
-                     WindowSurfaceWayland::GetQueue());
-  wl_buffer_add_listener(mBuffer, &buffer_listener, this);
+  int newBufferSize = aWidth*aHeight*BUFFER_BPP;
+  mShmBuffer.Resize(newBufferSize);
+
+  mWaylandBuffer = wl_shm_pool_create_buffer(mShmBuffer.GetShmPool(), 0,
+                                     			  aWidth, aHeight, aWidth*BUFFER_BPP,
+                                    			  WL_SHM_FORMAT_ARGB8888);
+  wl_proxy_set_queue((struct wl_proxy *)mWaylandBuffer,
+                     gWaylandDisplay->GetEventQueue());
+  wl_buffer_add_listener(mWaylandBuffer, &buffer_listener, this);
 
   mWidth = aWidth;
   mHeight = aHeight;
 }
 
-void BackBufferWayland::ReleaseBuffer()
+void WindowBackBuffer::Release()
 {
-  wl_buffer_destroy(mBuffer);
+  wl_buffer_destroy(mWaylandBuffer);
   mWidth = mHeight = 0;
 }
 
-BackBufferWayland::BackBufferWayland(int aWidth, int aHeight)
- : mShmPool(nullptr)
-  ,mShmPoolFd(0)
-  ,mAllocatedSize(0)
-  ,mBuffer(nullptr)
-  ,mBufferData(nullptr)
+WindowBackBuffer::WindowBackBuffer(int aWidth, int aHeight)
+ : mShmBuffer(aWidth*aHeight*BUFFER_BPP)
+  ,mWaylandBuffer(nullptr)
   ,mWidth(aWidth)
   ,mHeight(aHeight)
   ,mAttached(false)
 {
-  if(CreateShmPool(aWidth*aHeight*BUFFER_BPP)) {
-    CreateBuffer(aWidth, aHeight);
-  } else
-    assert(0);
+  Create(aWidth, aHeight);
 }
 
-BackBufferWayland::~BackBufferWayland()
+WindowBackBuffer::~WindowBackBuffer()
 {
-  ReleaseBuffer();
-  ReleaseShmPool();
+  Release();
 }
 
 bool
-BackBufferWayland::Resize(int aWidth, int aHeight)
+WindowBackBuffer::Resize(int aWidth, int aHeight)
 {
   if (aWidth == mWidth && aHeight == mHeight)
     return true;
 
   fprintf(stderr, "BackBufferResize, %dx%d -> %dx%d",
           mWidth, mHeight, aWidth, aHeight);
-  ReleaseBuffer();
 
-  int newSize = aWidth*aHeight*BUFFER_BPP;
-  if (newSize > mAllocatedSize)
-    ResizeShmPool(newSize);
+  Release();
+  Create(aWidth, aHeight);
 
-  CreateBuffer(aWidth, aHeight);
-  return (mBuffer != nullptr);
+  return (mWaylandBuffer != nullptr);
 }
 
 // Update back buffer with image data from ImageBuffer
 void
-BackBufferWayland::CopyRectangle(ImageBuffer *aImage,
-                                 const mozilla::LayoutDeviceIntRect &rect)
+WindowBackBuffer::CopyRectangle(ImageBuffer *aImage,
+                                const mozilla::LayoutDeviceIntRect &rect)
 {
   mozilla::LayoutDeviceIntRect r = rect;
 
@@ -253,14 +368,14 @@ BackBufferWayland::CopyRectangle(ImageBuffer *aImage,
   for (int y = r.y; y < r.y + r.height; y++) {
     int start = (y * mWidth + r.x) * BUFFER_BPP;
     int lenght = r.width * BUFFER_BPP;
-    memcpy((unsigned char *)mBufferData + start,
-            aImage->GetData() + ((y * aImage->mWidth) + r.x) * BUFFER_BPP,
+    memcpy((unsigned char *)mShmBuffer.GetImageData() + start,
+            aImage->GetImageData() + ((y * aImage->GetWidth()) + r.x) * BUFFER_BPP,
             lenght);
   }
 }
 
 void
-BackBufferWayland::Attach(wl_surface* aSurface)
+WindowBackBuffer::Attach(wl_surface* aSurface)
 {
   // Taken from Hybris project:
   // Some compositors, namely Weston, queue buffer release events instead
@@ -269,156 +384,40 @@ BackBufferWayland::Attach(wl_surface* aSurface)
   // request to ensure that they get flushed.
   //wl_callback_destroy(wl_display_sync(WindowSurfaceWayland::GetDisplay()));
 
-  wl_surface_attach(aSurface, mBuffer, 0, 0);
+  wl_surface_attach(aSurface, mWaylandBuffer, 0, 0);
   wl_surface_commit(aSurface);
-  wl_display_flush(WindowSurfaceWayland::GetDisplay());
+  wl_display_flush(gWaylandDisplay->GetDisplay());
   mAttached = true;
 }
 
 void
-BackBufferWayland::Detach()
+WindowBackBuffer::Detach()
 {
   mAttached = false;
 }
 
-bool BackBufferWayland::Sync(class BackBufferWayland* aSourceBuffer)
+bool WindowBackBuffer::Sync(class WindowBackBuffer* aSourceBuffer)
 {
   bool bufferSizeMatches = MatchSize(aSourceBuffer);
   if (!bufferSizeMatches) {
     Resize(aSourceBuffer->mWidth, aSourceBuffer->mHeight);
   }
 
-  memcpy(mBufferData, aSourceBuffer->mBufferData,
+  memcpy(mShmBuffer.GetImageData(), aSourceBuffer->mShmBuffer.GetImageData(),
          aSourceBuffer->mWidth * aSourceBuffer->mHeight * BUFFER_BPP);
   return true;
 }
 
-void
-WindowSurfaceWayland::SetWaylandPixelFormat(uint32_t format)
-{
-  switch (format) {
-    case WL_SHM_FORMAT_ARGB8888:
-      mFormat = gfx::SurfaceFormat::B8G8R8A8;
-      break;
-    case WL_SHM_FORMAT_XRGB8888:
-      // TODO - We can use non-alpha formats when we need that
-    default:
-      break;
-  }
-}
-
 static void
-shm_format(void *data, wl_shm *wl_shm, uint32_t format)
-{
-  auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
-  interface->SetWaylandPixelFormat(format);
- }
-
-struct wl_shm_listener shm_listener = {
-	shm_format
-};
-
-static void
-global_registry_handler(void *data, wl_registry *registry, uint32_t id,
-	                      const char *interface, uint32_t version)
-{
-  if (strcmp(interface, "wl_shm") == 0) {
-    auto shm = static_cast<wl_shm*>(
-        wl_registry_bind(registry, id, &wl_shm_interface, 1));
-    wl_proxy_set_queue((struct wl_proxy *)shm, WindowSurfaceWayland::GetQueue());
-    wl_shm_add_listener(shm, &shm_listener, NULL);
-    auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
-    interface->SetShm(shm);
-  }
-}
-
-static void
-global_registry_remover(void *data, wl_registry *registry, uint32_t id)
-{
-}
-
-static const struct wl_registry_listener registry_listener = {
-  global_registry_handler,
-  global_registry_remover
-};
-
-static gpointer
-gst_wl_display_thread_run (gpointer data)
-{
-  struct pollfd fds;
-  fds.fd = wl_display_get_fd (WindowSurfaceWayland::GetDisplay());
-  fds.events = POLLIN;
-
-  /* main loop */
-  while (1) {
-    while (wl_display_prepare_read_queue (WindowSurfaceWayland::GetDisplay(),
-                                          WindowSurfaceWayland::GetQueue()) < 0) {
-      wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
-                                         WindowSurfaceWayland::GetQueue());
-    }
-    wl_display_flush (WindowSurfaceWayland::GetDisplay());
-
-    int ret = poll(&fds, 1, -1);
-    if (ret == -1) {
-      wl_display_cancel_read(WindowSurfaceWayland::GetDisplay());
-      break;
-    }
-    wl_display_read_events(WindowSurfaceWayland::GetDisplay());
-    wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
-                                       WindowSurfaceWayland::GetQueue());
-  }
-
-  return NULL;
-}
-
-extern "C" {
-struct wl_event_queue* moz_container_get_wl_queue();
-
-static void
-redraw(void *data, struct wl_callback *callback, uint32_t time)
+frame_callback_handler(void *data, struct wl_callback *callback, uint32_t time)
 {
     auto surface = reinterpret_cast<WindowSurfaceWayland*>(data);
-    surface->Draw();
+    surface->FrameCallbackHandler();
 }
 
 static const struct wl_callback_listener frame_listener = {
-    redraw
+    frame_callback_handler
 };
-}
-
-void
-WindowSurfaceWayland::Init()
-{
-  // Try to initialize only once
-  if (mInitialized)
-    return;
-  mInitialized = true;
-
-  mQueue = wl_display_create_queue(mDisplay);
-
-  // wl_shm and wl_subcompositor are not provided by Gtk so we need
-  // to query wayland directly
-  wl_registry* registry = wl_display_get_registry(mDisplay);
-  wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
-  wl_registry_add_listener(registry,
-                           &registry_listener, nullptr);
-
-  // We need two roundtrips here to get the registry info
-  wl_display_dispatch_queue(mDisplay, mQueue);
-  wl_display_roundtrip_queue(mDisplay, mQueue);
-
-  wl_display_roundtrip_queue(mDisplay, mQueue);
-
-  // We should have a valid pixel format now
-  mIsAvailable = (mFormat != gfx::SurfaceFormat::UNKNOWN);
-  NS_ASSERTION(mIsAvailable, "We don't have any pixel format!");
-
-  assert(mFormat != gfx::SurfaceFormat::UNKNOWN);
-
-  GError *err = nullptr;
-  mThread = g_thread_try_new ("GstWlDisplay", gst_wl_display_thread_run,
-                              this, &err);
-}
 
 WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
                                            wl_display *aDisplay,
@@ -430,13 +429,15 @@ WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
   , mFrameCallback(nullptr)
   , mDelayedCommit(false)
 {
-  NS_ASSERTION(mSurface != nullptr,
-               "Missing Wayland surfaces to draw to!");
-
-  mDisplay = aDisplay;
-  Init();
-
-  wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);
+  MOZ_RELEASE_ASSERT(mSurface != nullptr,
+                    "We can't do anything useful without valid wl_surface.");
+  // Ensure we have valid display connection
+  WaylandDisplayInit(aDisplay);
+
+  // Make sure the drawing surface is handled by our event loop
+  // and not the default (Gdk) one to draw out of main thread.
+  wl_proxy_set_queue((struct wl_proxy *)mSurface,
+                     gWaylandDisplay->GetEventQueue());
 }
 
 WindowSurfaceWayland::~WindowSurfaceWayland()
@@ -449,12 +450,12 @@ WindowSurfaceWayland::~WindowSurfaceWayland()
   }
 }
 
-BackBufferWayland*
+WindowBackBuffer*
 WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
 {
   if (!mFrontBuffer) {
-    mFrontBuffer = new BackBufferWayland(aWidth, aHeight);
-    mBackBuffer = new BackBufferWayland(aWidth, aHeight);
+    mFrontBuffer = new WindowBackBuffer(aWidth, aHeight);
+    mBackBuffer = new WindowBackBuffer(aWidth, aHeight);
   } else {
     if (mFrontBuffer->IsAttached()) {
 
@@ -463,10 +464,11 @@ WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
         return nullptr;
       }
 
-      BackBufferWayland *tmp = mFrontBuffer;
+      WindowBackBuffer *tmp = mFrontBuffer;
       mFrontBuffer = mBackBuffer;
       mBackBuffer = tmp;
 
+      // TODO sync only when we don't resize after switch
       mFrontBuffer->Sync(mBackBuffer);
 
       // TODO (https://bugzilla.redhat.com/show_bug.cgi?id=1418260)
@@ -484,6 +486,9 @@ WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
 already_AddRefed<gfx::DrawTarget>
 WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
 {
+  // TODO -> compare with bound size
+  // and provide back buffer direcly when possible
+  // (no data in img buffer and size match)
   return mImageBuffer.Lock(aRegion);
 }
 
@@ -494,13 +499,14 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
   gfx::IntSize bufferSize(bounds.XMost(), bounds.YMost());
 
   LayoutDeviceIntRect rect = mWidget->GetBounds();
-  BackBufferWayland* buffer = GetBufferToDraw(rect.width,
-                                              rect.height);
+  WindowBackBuffer* buffer = GetBufferToDraw(rect.width,
+                                             rect.height);
   NS_ASSERTION(buffer, "We don't have any buffer to draw to!");
   if (!buffer) {
     return;
   }
 
+  // TODO - overlapping areas?
   for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
     const mozilla::LayoutDeviceIntRect &r = iter.Get();
     buffer->CopyRectangle(&mImageBuffer, r);
@@ -524,7 +530,7 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
 }
 
 void
-WindowSurfaceWayland::Draw()
+WindowSurfaceWayland::FrameCallbackHandler()
 {
   if (mFrameCallback) {
       wl_callback_destroy(mFrameCallback);
@@ -532,6 +538,8 @@ WindowSurfaceWayland::Draw()
   }
 
   if (mDelayedCommit) {
+    // Send pending surface to compositor and register frame callback
+    // for possible subsequent drawing.
     mFrameCallback = wl_surface_frame(mSurface);
     wl_callback_add_listener(mFrameCallback, &frame_listener, this);
 
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
index dfc504958870..707c796389ac 100644
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -13,67 +13,99 @@ namespace widget {
 // We support only 32bpp formats
 #define BUFFER_BPP 4
 
-// Image surface which holds actual drawing to back buffer,
-// it is commited to BackBufferWayland
+// Our general connection to Wayland display server,
+// holds our display connection and runs event loop.
+class WaylandDisplay {
+public:
+  WaylandDisplay(wl_display *aDisplay);
+  ~WaylandDisplay();
+
+  void               SetShm(wl_shm* aShm)   { mShm = aShm; };
+  wl_shm*            GetShm()               { return(mShm); };
+  wl_event_queue*    GetEventQueue()        { return mEventQueue; };
+  wl_display*        GetDisplay()           { return mDisplay; };
+  gfx::SurfaceFormat GetSurfaceFormat()     { return mFormat; };
+  void               SetWaylandPixelFormat(uint32_t format);
+
+private:
+  gfx::SurfaceFormat mFormat;
+  wl_shm*            mShm;
+  wl_event_queue*    mEventQueue;
+  GThread*           mLoopThread;
+  wl_display*        mDisplay;
+};
+
 class ImageBuffer {
-friend class BackBufferWayland;
 public:
   ImageBuffer();
   ~ImageBuffer();
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion);
-  unsigned char* GetData() { return mBufferData; };
+  unsigned char* GetImageData()  { return mImageData; };
+  int GetWidth()                 { return mWidth; };
+  int GetHeight()                { return mHeight; };
 
 private:
-  unsigned char*     mBufferData;
+  unsigned char*     mImageData;
   int                mBufferAllocated;
   int                mWidth;
   int                mHeight;
 };
 
-// Holds actual graphics data for wl_surface
-class BackBufferWayland {
+// Allocates and owns shared memory for Wayland drawing surfaces
+class WaylandShmBuffer {
 public:
-  BackBufferWayland(int aWidth, int aHeight);
-  ~BackBufferWayland();
+  WaylandShmBuffer(int aSize);
+  ~WaylandShmBuffer();
 
-  void CopyRectangle(ImageBuffer *aImage,
-                     const mozilla::LayoutDeviceIntRect &rect);
+  bool          Resize(int aSize);
+  wl_shm_pool*  GetShmPool()    { return mShmPool;    };
+  void*         GetImageData()  { return mImageData; };
+
+private:
+  int CreateTemporaryFile(int aSize);
+
+  wl_shm_pool*       mShmPool;
+  int                mShmPoolFd;
+  int                mAllocatedSize;
+  void*              mImageData;
+};
+
+// Holds actual graphics data for wl_surface
+class WindowBackBuffer {
+public:
+  WindowBackBuffer(int aWidth, int aHeight);
+  ~WindowBackBuffer();
 
   void Attach(wl_surface* aSurface);
   void Detach();
   bool IsAttached() { return mAttached; }
 
   bool Resize(int aWidth, int aHeight);
-  bool Sync(class BackBufferWayland* aSourceBuffer);
+  bool Sync(class WindowBackBuffer* aSourceBuffer);
 
   bool MatchSize(int aWidth, int aHeight)
   {
     return aWidth == mWidth && aHeight == mHeight;
   }
-  bool MatchSize(class BackBufferWayland *aBuffer)
+  bool MatchSize(class WindowBackBuffer *aBuffer)
   {
     return aBuffer->mWidth == mWidth && aBuffer->mHeight == mHeight;
   }
 
-  bool MatchAllocatedSize(int aSize)
-  {
-    return aSize <= mAllocatedSize;
-  }
+  void CopyRectangle(ImageBuffer *aImage,
+                     const mozilla::LayoutDeviceIntRect &rect);
 
 private:
-  bool CreateShmPool(int aSize);
-  bool ResizeShmPool(int aSize);
-  void ReleaseShmPool(void);
+  void Create(int aWidth, int aHeight);
+  void Release();
 
-  void CreateBuffer(int aWidth, int aHeight);
-  void ReleaseBuffer();
+  // WaylandShmBuffer provides actual shared memory we draw into
+  WaylandShmBuffer   mShmBuffer;
 
-  wl_shm_pool*       mShmPool;
-  int                mShmPoolFd;
-  int                mAllocatedSize;
-  wl_buffer*         mBuffer;
-  void*              mBufferData;
+  // wl_buffer is a wayland object that encapsulates the shared memory
+  // and passes it to wayland compositor by wl_surface object.
+  wl_buffer*         mWaylandBuffer;
   int                mWidth;
   int                mHeight;
   bool               mAttached;
@@ -88,26 +120,10 @@ public:
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
   void                      Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
-  void                      Draw();
-
-  static void               SetShm(wl_shm* aShm) { mShm = aShm; };
-  static wl_shm*            GetShm() { return(mShm); };
-  static wl_event_queue*    GetQueue() { return mQueue; };
-  static wl_display*        GetDisplay() { return mDisplay; };
-  static void               SetWaylandPixelFormat(uint32_t format);
-  static gfx::SurfaceFormat GetSurfaceFormat() { return mFormat; };
+  void                      FrameCallbackHandler();
 
 private:
-  BackBufferWayland*        GetBufferToDraw(int aWidth, int aHeight);
-  void                      Init();
-
-  static bool               mIsAvailable;
-  static bool               mInitialized;
-  static gfx::SurfaceFormat mFormat;
-  static wl_shm*            mShm;
-  static wl_event_queue*    mQueue;
-  static GThread*           mThread;
-  static wl_display*        mDisplay;
+  WindowBackBuffer*         GetBufferToDraw(int aWidth, int aHeight);
 
   nsWindow*                 mWidget;
 
@@ -120,8 +136,8 @@ private:
 
   ImageBuffer               mImageBuffer;
 
-  BackBufferWayland*        mFrontBuffer;
-  BackBufferWayland*        mBackBuffer;
+  WindowBackBuffer*         mFrontBuffer;
+  WindowBackBuffer*         mBackBuffer;
   wl_callback*              mFrameCallback;
   bool                      mDelayedCommit;
 };
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index 2f3c3c4cd1d3..1cc8917e7b87 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -37,7 +37,6 @@ UNIFIED_SOURCES += [
     'nsSound.cpp',
     'nsToolkit.cpp',
     'nsWidgetFactory.cpp',
-    'os-compatibility.c',
     'WakeLockListener.cpp',
     'WidgetTraceEvent.cpp',
     'WidgetUtilsGtk.cpp',
diff --git a/widget/gtk/os-compatibility.c b/widget/gtk/os-compatibility.c
deleted file mode 100644
index 3439075ad752..000000000000
--- a/widget/gtk/os-compatibility.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright © 2012 Collabora, Ltd.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/*
-* This file is a part of Weston project,
-* https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.c
-*/
-
-#include "mozilla-config.h"
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/epoll.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "os-compatibility.h"
-
-int
-os_fd_set_cloexec(int fd)
-{
-	long flags;
-
-	if (fd == -1)
-		return -1;
-
-	flags = fcntl(fd, F_GETFD);
-	if (flags == -1)
-		return -1;
-
-	if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
-		return -1;
-
-	return 0;
-}
-
-static int
-set_cloexec_or_close(int fd)
-{
-	if (os_fd_set_cloexec(fd) != 0) {
-		close(fd);
-		return -1;
-	}
-	return fd;
-}
-
-int
-os_socketpair_cloexec(int domain, int type, int protocol, int *sv)
-{
-	int ret;
-
-#ifdef SOCK_CLOEXEC
-	ret = socketpair(domain, type | SOCK_CLOEXEC, protocol, sv);
-	if (ret == 0 || errno != EINVAL)
-		return ret;
-#endif
-
-	ret = socketpair(domain, type, protocol, sv);
-	if (ret < 0)
-		return ret;
-
-	sv[0] = set_cloexec_or_close(sv[0]);
-	sv[1] = set_cloexec_or_close(sv[1]);
-
-	if (sv[0] != -1 && sv[1] != -1)
-		return 0;
-
-	close(sv[0]);
-	close(sv[1]);
-	return -1;
-}
-
-int
-os_epoll_create_cloexec(void)
-{
-	int fd;
-
-#ifdef EPOLL_CLOEXEC
-	fd = epoll_create1(EPOLL_CLOEXEC);
-	if (fd >= 0)
-		return fd;
-	if (errno != EINVAL)
-		return -1;
-#endif
-
-	fd = epoll_create(1);
-	return set_cloexec_or_close(fd);
-}
-
-static int
-create_tmpfile_cloexec(char *tmpname)
-{
-	int fd;
-
-#ifdef HAVE_MKOSTEMP
-	fd = mkostemp(tmpname, O_CLOEXEC);
-	if (fd >= 0)
-		unlink(tmpname);
-#else
-	fd = mkstemp(tmpname);
-	if (fd >= 0) {
-		fd = set_cloexec_or_close(fd);
-		unlink(tmpname);
-	}
-#endif
-
-	return fd;
-}
-
-/*
- * Create a new, unique, anonymous file of the given size, and
- * return the file descriptor for it. The file descriptor is set
- * CLOEXEC. The file is immediately suitable for mmap()'ing
- * the given size at offset zero.
- *
- * The file should not have a permanent backing store like a disk,
- * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
- *
- * The file name is deleted from the file system.
- *
- * The file is suitable for buffer sharing between processes by
- * transmitting the file descriptor over Unix sockets using the
- * SCM_RIGHTS methods.
- *
- * If the C library implements posix_fallocate(), it is used to
- * guarantee that disk space is available for the file at the
- * given size. If disk space is insufficent, errno is set to ENOSPC.
- * If posix_fallocate() is not supported, program may receive
- * SIGBUS on accessing mmap()'ed file contents instead.
- */
-int
-os_create_anonymous_file(off_t size)
-{
-	static const char template[] = "/weston-shared-XXXXXX";
-	const char *path;
-	char *name;
-	int fd;
-	int ret;
-
-	path = getenv("XDG_RUNTIME_DIR");
-	if (!path) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	name = malloc(strlen(path) + sizeof(template));
-	if (!name)
-		return -1;
-
-	strcpy(name, path);
-	strcat(name, template);
-
-	fd = create_tmpfile_cloexec(name);
-
-	free(name);
-
-	if (fd < 0)
-		return -1;
-
-#ifdef HAVE_POSIX_FALLOCATE
-	ret = posix_fallocate(fd, 0, size);
-	if (ret != 0) {
-		close(fd);
-		errno = ret;
-		return -1;
-	}
-#else
-	ret = ftruncate(fd, size);
-	if (ret < 0) {
-		close(fd);
-		return -1;
-	}
-#endif
-
-	return fd;
-}
diff --git a/widget/gtk/os-compatibility.h b/widget/gtk/os-compatibility.h
deleted file mode 100644
index 5dbd3b616104..000000000000
--- a/widget/gtk/os-compatibility.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright © 2012 Collabora, Ltd.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
- /*
-  * This file is a part of Weston project,
-  * https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.h
-  */
-
-#ifndef OS_COMPATIBILITY_H
-#define OS_COMPATIBILITY_H
-
-#include <sys/types.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-int
-os_fd_set_cloexec(int fd);
-
-int
-os_socketpair_cloexec(int domain, int type, int protocol, int *sv);
-
-int
-os_epoll_create_cloexec(void);
-
-int
-os_create_anonymous_file(off_t size);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* OS_COMPATIBILITY_H */
-- 
2.11.0


From 2633c717ec1968abf40bd80fb57deb208ad84a18 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Tue, 23 May 2017 17:14:22 +0200
Subject: [PATCH] Use wl_display_dispatch_queue_pending() to fetch wayland
 events and run the loop with 60fps

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 widget/gtk/WindowSurfaceWayland.cpp | 16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index 48246cf8f19f..9afbaeb47a3c 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -37,6 +37,8 @@ static nsWaylandDisplay* WaylandDisplayGet(wl_display *aDisplay);
 static void WaylandDisplayRelease(wl_display *aDisplay);
 static void WaylandDisplayLoop(wl_display *aDisplay);
 
+#define EVENT_LOOP_DELAY (1000/60)
+
 // Get WaylandDisplay for given wl_display and actual calling thread.
 static nsWaylandDisplay*
 WaylandDisplayGetLocked(wl_display *aDisplay, const StaticMutexAutoLock&)
@@ -102,8 +104,8 @@ WaylandDisplayLoopLocked(wl_display* aDisplay,
   for (int i = 0; i < len; i++) {
     if (gWaylandDisplays[i]->Matches(aDisplay)) {
       if (gWaylandDisplays[i]->DisplayLoop()) {
-        MessageLoop::current()->PostTask(
-            NewRunnableFunction(&WaylandDisplayLoop, aDisplay));
+        MessageLoop::current()->PostDelayedTask(
+            NewRunnableFunction(&WaylandDisplayLoop, aDisplay), EVENT_LOOP_DELAY);
       }
       break;
     }
@@ -175,14 +177,8 @@ nsWaylandDisplay::GetShm()
 bool
 nsWaylandDisplay::DisplayLoop()
 {
-  /* NoteThis function may dispatch other events being received on the given
-     queue. This function uses wl_display_dispatch_queue() internally.
-     If you are using wl_display_read_events() from more threads,
-     don't use this function (or make sure that calling wl_display_roundtrip_queue()
-     doesn't interfere with calling wl_display_prepare_read() and
-     wl_display_read_events()).
-  */
-  return wl_display_roundtrip_queue(mDisplay, mEventQueue) != -1;
+  wl_display_dispatch_queue_pending(mDisplay, mEventQueue);
+  return true;
 }
 
 bool
-- 
2.11.0


From 4a914ff3711184e4e8736ce7328c9c859493ffe4 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Thu, 13 Apr 2017 14:29:23 +0200
Subject: [PATCH 3/9] replace

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 toolkit/components/remote/nsDBusRemoteService.cpp | 376 +++++++---------------
 toolkit/components/remote/nsDBusRemoteService.h   |  77 ++---
 2 files changed, 150 insertions(+), 303 deletions(-)

diff --git a/toolkit/components/remote/nsDBusRemoteService.cpp b/toolkit/components/remote/nsDBusRemoteService.cpp
index af3d1229b19d..860efe0150ce 100644
--- a/toolkit/components/remote/nsDBusRemoteService.cpp
+++ b/toolkit/components/remote/nsDBusRemoteService.cpp
@@ -5,317 +5,177 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/ArrayUtils.h"
+#include "nsGTKRemoteService.h"
 
-#include "nsXRemoteService.h"
-#include "nsIObserverService.h"
-#include "nsCOMPtr.h"
-#include "nsIServiceManager.h"
-#include "nsICommandLineRunner.h"
-#include "nsICommandLine.h"
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
 
 #include "nsIBaseWindow.h"
 #include "nsIDocShell.h"
-#include "nsIFile.h"
+#include "nsPIDOMWindow.h"
+#include "mozilla/ModuleUtils.h"
 #include "nsIServiceManager.h"
 #include "nsIWeakReference.h"
 #include "nsIWidget.h"
 #include "nsIAppShellService.h"
 #include "nsAppShellCID.h"
-#include "nsPIDOMWindow.h"
-#include "mozilla/X11Util.h"
 
 #include "nsCOMPtr.h"
-#include "nsString.h"
-#include "prenv.h"
-#include "nsCRT.h"
 
-#include "nsXULAppAPI.h"
+#include "nsGTKToolkit.h"
 
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
+NS_IMPL_ISUPPORTS(nsGTKRemoteService,
+                  nsIRemoteService,
+                  nsIObserver)
 
-using namespace mozilla;
+NS_IMETHODIMP
+nsGTKRemoteService::Startup(const char* aAppName, const char* aProfileName)
+{
+  NS_ASSERTION(aAppName, "Don't pass a null appname!");
+  sRemoteImplementation = this;
 
-#define MOZILLA_VERSION_PROP   "_MOZILLA_VERSION"
-#define MOZILLA_LOCK_PROP      "_MOZILLA_LOCK"
-#define MOZILLA_RESPONSE_PROP  "_MOZILLA_RESPONSE"
-#define MOZILLA_USER_PROP      "_MOZILLA_USER"
-#define MOZILLA_PROFILE_PROP   "_MOZILLA_PROFILE"
-#define MOZILLA_PROGRAM_PROP   "_MOZILLA_PROGRAM"
-#define MOZILLA_COMMANDLINE_PROP "_MOZILLA_COMMANDLINE"
+  if (mServerWindow) return NS_ERROR_ALREADY_INITIALIZED;
 
-const unsigned char kRemoteVersion[] = "5.1";
+  XRemoteBaseStartup(aAppName, aProfileName);
 
-#ifdef IS_BIG_ENDIAN
-#define TO_LITTLE_ENDIAN32(x) \
-    ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \
-    (((x) & 0x0000ff00) << 8) | (((x) & 0x000000ff) << 24))
-#else
-#define TO_LITTLE_ENDIAN32(x) (x)
-#endif
+  mServerWindow = gtk_invisible_new();
+  gtk_widget_realize(mServerWindow);
+  HandleCommandsFor(mServerWindow, nullptr);
 
-// Minimize the roundtrips to the X server by getting all the atoms at once
-static const char *XAtomNames[] = {
-  MOZILLA_VERSION_PROP,
-  MOZILLA_LOCK_PROP,
-  MOZILLA_RESPONSE_PROP,
-  MOZILLA_USER_PROP,
-  MOZILLA_PROFILE_PROP,
-  MOZILLA_PROGRAM_PROP,
-  MOZILLA_COMMANDLINE_PROP
-};
-static Atom XAtoms[MOZ_ARRAY_LENGTH(XAtomNames)];
-
-Atom nsXRemoteService::sMozVersionAtom;
-Atom nsXRemoteService::sMozLockAtom;
-Atom nsXRemoteService::sMozResponseAtom;
-Atom nsXRemoteService::sMozUserAtom;
-Atom nsXRemoteService::sMozProfileAtom;
-Atom nsXRemoteService::sMozProgramAtom;
-Atom nsXRemoteService::sMozCommandLineAtom;
-
-nsXRemoteService * nsXRemoteService::sRemoteImplementation = 0;
+  for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
+    HandleCommandsFor(iter.Key(), iter.UserData());
+  }
 
+  return NS_OK;
+}
 
-static bool
-FindExtensionParameterInCommand(const char* aParameterName,
-                                const nsACString& aCommand,
-                                char aSeparator,
-                                nsACString* aValue)
+static nsIWidget* GetMainWidget(nsPIDOMWindowInner* aWindow)
 {
-  nsAutoCString searchFor;
-  searchFor.Append(aSeparator);
-  searchFor.Append(aParameterName);
-  searchFor.Append('=');
-
-  nsACString::const_iterator start, end;
-  aCommand.BeginReading(start);
-  aCommand.EndReading(end);
-  if (!FindInReadable(searchFor, start, end))
-    return false;
-
-  nsACString::const_iterator charStart, charEnd;
-  charStart = end;
-  aCommand.EndReading(charEnd);
-  nsACString::const_iterator idStart = charStart, idEnd;
-  if (FindCharInReadable(aSeparator, charStart, charEnd)) {
-    idEnd = charStart;
-  } else {
-    idEnd = charEnd;
-  }
-  *aValue = nsDependentCSubstring(idStart, idEnd);
-  return true;
+  // get the native window for this instance
+  nsCOMPtr<nsIBaseWindow> baseWindow
+    (do_QueryInterface(aWindow->GetDocShell()));
+  NS_ENSURE_TRUE(baseWindow, nullptr);
+
+  nsCOMPtr<nsIWidget> mainWidget;
+  baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
+  return mainWidget;
 }
 
-
-nsXRemoteService::nsXRemoteService() = default;
-
-void
-nsXRemoteService::XRemoteBaseStartup(const char *aAppName, const char *aProfileName)
+NS_IMETHODIMP
+nsGTKRemoteService::RegisterWindow(mozIDOMWindow* aWindow)
 {
-    EnsureAtoms();
+  nsIWidget* mainWidget = GetMainWidget(nsPIDOMWindowInner::From(aWindow));
+  NS_ENSURE_TRUE(mainWidget, NS_ERROR_FAILURE);
 
-    mAppName = aAppName;
-    ToLowerCase(mAppName);
-
-    mProfileName = aProfileName;
-
-    nsCOMPtr<nsIObserverService> obs(do_GetService("@mozilla.org/observer-service;1"));
-    if (obs) {
-      obs->AddObserver(this, "xpcom-shutdown", false);
-      obs->AddObserver(this, "quit-application", false);
-    }
-}
+  GtkWidget* widget =
+    (GtkWidget*) mainWidget->GetNativeData(NS_NATIVE_SHELLWIDGET);
+  NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 
-void 
-nsXRemoteService::HandleCommandsFor(Window aWindowId)
-{
-  // set our version
-  XChangeProperty(mozilla::DefaultXDisplay(), aWindowId, sMozVersionAtom, XA_STRING,
-                  8, PropModeReplace, kRemoteVersion, sizeof(kRemoteVersion) - 1);
-
-  // get our username
-  unsigned char *logname;
-  logname = (unsigned char*) PR_GetEnv("LOGNAME");
-  if (logname) {
-    // set the property on the window if it's available
-    XChangeProperty(mozilla::DefaultXDisplay(), aWindowId, sMozUserAtom, XA_STRING,
-                    8, PropModeReplace, logname, strlen((char*) logname));
-  }
+  nsCOMPtr<nsIWeakReference> weak = do_GetWeakReference(aWindow);
+  NS_ENSURE_TRUE(weak, NS_ERROR_FAILURE);
 
-  XChangeProperty(mozilla::DefaultXDisplay(), aWindowId, sMozProgramAtom, XA_STRING,
-                  8, PropModeReplace, (unsigned char*) mAppName.get(), mAppName.Length());
+  mWindows.Put(widget, weak);
 
-  if (!mProfileName.IsEmpty()) {
-    XChangeProperty(mozilla::DefaultXDisplay(),
-                    aWindowId, sMozProfileAtom, XA_STRING,
-                    8, PropModeReplace,
-                    (unsigned char*) mProfileName.get(), mProfileName.Length());
+  // If Startup() has already been called, immediately register this window.
+  if (mServerWindow) {
+    HandleCommandsFor(widget, weak);
   }
 
+  return NS_OK;
 }
 
 NS_IMETHODIMP
-nsXRemoteService::Observe(nsISupports* aSubject,
-                          const char *aTopic,
-                          const char16_t *aData)
+nsGTKRemoteService::Shutdown()
 {
-  // This can be xpcom-shutdown or quit-application, but it's the same either
-  // way.
-  Shutdown();
+  if (!mServerWindow)
+    return NS_ERROR_NOT_INITIALIZED;
+
+  gtk_widget_destroy(mServerWindow);
+  mServerWindow = nullptr;
   return NS_OK;
 }
 
-bool
-nsXRemoteService::HandleNewProperty(XID aWindowId, Display* aDisplay,
-                                    Time aEventTime,
-                                    Atom aChangedAtom,
-                                    nsIWeakReference* aDomWindow)
-{
-
-  nsCOMPtr<nsIDOMWindow> window (do_QueryReferent(aDomWindow));
-
-  if (aChangedAtom == sMozCommandLineAtom) {
-    // We got a new command atom.
-    int result;
-    Atom actual_type;
-    int actual_format;
-    unsigned long nitems, bytes_after;
-    char *data = 0;
-
-    result = XGetWindowProperty (aDisplay,
-                                 aWindowId,
-                                 aChangedAtom,
-                                 0,                        /* long_offset */
-                                 (65536 / sizeof (long)),  /* long_length */
-                                 True,                     /* atomic delete after */
-                                 XA_STRING,                /* req_type */
-                                 &actual_type,             /* actual_type return */
-                                 &actual_format,           /* actual_format_return */
-                                 &nitems,                  /* nitems_return */
-                                 &bytes_after,             /* bytes_after_return */
-                                 (unsigned char **)&data); /* prop_return
-                                                              (we only care
-                                                              about the first ) */
-
-    // Failed to get property off the window?
-    if (result != Success)
-      return false;
-
-    // Failed to get the data off the window or it was the wrong type?
-    if (!data || !TO_LITTLE_ENDIAN32(*reinterpret_cast<int32_t*>(data)))
-      return false;
-
-    // cool, we got the property data.
-    const char *response = HandleCommandLine(data, window, aEventTime);
-
-    // put the property onto the window as the response
-    XChangeProperty (aDisplay, aWindowId,
-                     sMozResponseAtom, XA_STRING,
-                     8, PropModeReplace,
-                     (const unsigned char *)response,
-                     strlen (response));
-    XFree(data);
-    return true;
-  }
-
-  if (aChangedAtom == sMozResponseAtom) {
-    // client accepted the response.  party on wayne.
-    return true;
-  }
+// Set desktop startup ID to the passed ID, if there is one, so that any created
+// windows get created with the right window manager metadata, and any windows
+// that get new tabs and are activated also get the right WM metadata.
+// The timestamp will be used if there is no desktop startup ID, or if we're
+// raising an existing window rather than showing a new window for the first time.
+void
+nsGTKRemoteService::SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
+                                                   uint32_t aTimestamp) {
+  nsGTKToolkit* toolkit = nsGTKToolkit::GetToolkit();
+  if (!toolkit)
+    return;
 
-  else if (aChangedAtom == sMozLockAtom) {
-    // someone locked the window
-    return true;
+  if (!aDesktopStartupID.IsEmpty()) {
+    toolkit->SetDesktopStartupID(aDesktopStartupID);
   }
 
-  return false;
+  toolkit->SetFocusTimestamp(aTimestamp);
 }
 
-const char*
-nsXRemoteService::HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
-                                    uint32_t aTimestamp)
-{
-  nsresult rv;
-
-  nsCOMPtr<nsICommandLineRunner> cmdline
-    (do_CreateInstance("@mozilla.org/toolkit/command-line;1", &rv));
-  if (NS_FAILED(rv))
-    return "509 internal error";
-
-  // the commandline property is constructed as an array of int32_t
-  // followed by a series of null-terminated strings:
-  //
-  // [argc][offsetargv0][offsetargv1...]<workingdir>\0<argv[0]>\0argv[1]...\0
-  // (offset is from the beginning of the buffer)
-
-  int32_t argc = TO_LITTLE_ENDIAN32(*reinterpret_cast<int32_t*>(aBuffer));
-  char *wd   = aBuffer + ((argc + 1) * sizeof(int32_t));
 
-  nsCOMPtr<nsIFile> lf;
-  rv = NS_NewNativeLocalFile(nsDependentCString(wd), true,
-                             getter_AddRefs(lf));
-  if (NS_FAILED(rv))
-    return "509 internal error";
-
-  nsAutoCString desktopStartupID;
-
-  char **argv = (char**) malloc(sizeof(char*) * argc);
-  if (!argv) return "509 internal error";
+void
+nsGTKRemoteService::HandleCommandsFor(GtkWidget* widget,
+                                      nsIWeakReference* aWindow)
+{
+  g_signal_connect(G_OBJECT(widget), "property_notify_event",
+                   G_CALLBACK(HandlePropertyChange), aWindow);
 
-  int32_t  *offset = reinterpret_cast<int32_t*>(aBuffer) + 1;
+  gtk_widget_add_events(widget, GDK_PROPERTY_CHANGE_MASK);
 
-  for (int i = 0; i < argc; ++i) {
-    argv[i] = aBuffer + TO_LITTLE_ENDIAN32(offset[i]);
+#if (MOZ_WIDGET_GTK == 2)
+  Window window = GDK_WINDOW_XWINDOW(widget->window);
+#else
+  Window window = gdk_x11_window_get_xid(gtk_widget_get_window(widget));
+#endif
+  nsXRemoteService::HandleCommandsFor(window);
 
-    if (i == 0) {
-      nsDependentCString cmd(argv[0]);
-      FindExtensionParameterInCommand("DESKTOP_STARTUP_ID",
-                                      cmd, ' ',
-                                      &desktopStartupID);
-    }
-  }
+}
 
-  rv = cmdline->Init(argc, argv, lf, nsICommandLine::STATE_REMOTE_AUTO);
+gboolean
+nsGTKRemoteService::HandlePropertyChange(GtkWidget *aWidget,
+                                         GdkEventProperty *pevent,
+                                         nsIWeakReference *aThis)
+{
+  if (pevent->state == GDK_PROPERTY_NEW_VALUE) {
+    Atom changedAtom = gdk_x11_atom_to_xatom(pevent->atom);
 
-  free (argv);
-  if (NS_FAILED(rv)) {
-    return "509 internal error";
+#if (MOZ_WIDGET_GTK == 2)
+    XID window = GDK_WINDOW_XWINDOW(pevent->window);
+#else
+    XID window = gdk_x11_window_get_xid(gtk_widget_get_window(aWidget));
+#endif
+    return HandleNewProperty(window,
+                             GDK_DISPLAY_XDISPLAY(gdk_display_get_default()),
+                             pevent->time, changedAtom, aThis);
   }
+  return FALSE;
+}
 
-  if (aWindow)
-    cmdline->SetWindowContext(aWindow);
-
-  if (sRemoteImplementation)
-    sRemoteImplementation->SetDesktopStartupIDOrTimestamp(desktopStartupID, aTimestamp);
 
-  rv = cmdline->Run();
+// {C0773E90-5799-4eff-AD03-3EBCD85624AC}
+#define NS_REMOTESERVICE_CID \
+  { 0xc0773e90, 0x5799, 0x4eff, { 0xad, 0x3, 0x3e, 0xbc, 0xd8, 0x56, 0x24, 0xac } }
 
-  if (NS_ERROR_ABORT == rv)
-    return "500 command not parseable";
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsGTKRemoteService)
+NS_DEFINE_NAMED_CID(NS_REMOTESERVICE_CID);
 
-  if (NS_FAILED(rv))
-    return "509 internal error";
+static const mozilla::Module::CIDEntry kRemoteCIDs[] = {
+  { &kNS_REMOTESERVICE_CID, false, nullptr, nsGTKRemoteServiceConstructor },
+  { nullptr }
+};
 
-  return "200 executed command";
-}
+static const mozilla::Module::ContractIDEntry kRemoteContracts[] = {
+  { "@mozilla.org/toolkit/remote-service;1", &kNS_REMOTESERVICE_CID },
+  { nullptr }
+};
 
-void
-nsXRemoteService::EnsureAtoms(void)
-{
-  if (sMozVersionAtom)
-    return;
+static const mozilla::Module kRemoteModule = {
+  mozilla::Module::kVersion,
+  kRemoteCIDs,
+  kRemoteContracts
+};
 
-  XInternAtoms(mozilla::DefaultXDisplay(), const_cast<char**>(XAtomNames),
-               ArrayLength(XAtomNames), False, XAtoms);
-
-  int i = 0;
-  sMozVersionAtom     = XAtoms[i++];
-  sMozLockAtom        = XAtoms[i++];
-  sMozResponseAtom    = XAtoms[i++];
-  sMozUserAtom        = XAtoms[i++];
-  sMozProfileAtom     = XAtoms[i++];
-  sMozProgramAtom     = XAtoms[i++];
-  sMozCommandLineAtom = XAtoms[i++];
-}
+NSMODULE_DEFN(RemoteServiceModule) = &kRemoteModule;
diff --git a/toolkit/components/remote/nsDBusRemoteService.h b/toolkit/components/remote/nsDBusRemoteService.h
index 7186336751b8..034a77a24c78 100644
--- a/toolkit/components/remote/nsDBusRemoteService.h
+++ b/toolkit/components/remote/nsDBusRemoteService.h
@@ -1,62 +1,49 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:expandtab:shiftwidth=2:tabstop=8:
+/* vim:expandtab:shiftwidth=2:tabstop=2:
  */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef NSXREMOTESERVICE_H
-#define NSXREMOTESERVICE_H
+#ifndef __nsGTKRemoteService_h__
+#define __nsGTKRemoteService_h__
 
-#include "nsString.h"
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
 
-#include "nsIRemoteService.h"
-#include "nsIObserver.h"
-#include <X11/Xlib.h>
-#include <X11/X.h>
+#include "nsInterfaceHashtable.h"
+#include "nsXRemoteService.h"
+#include "mozilla/Attributes.h"
 
-class nsIDOMWindow;
-class nsIWeakReference;
-
-/**
-  Base class for GTK/Qt remote service
-*/
-class nsXRemoteService : public nsIRemoteService,
-                         public nsIObserver
+class nsGTKRemoteService final : public nsXRemoteService
 {
 public:
-    NS_DECL_NSIOBSERVER
-
+  // We will be a static singleton, so don't use the ordinary methods.
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIREMOTESERVICE
 
-protected:
-    nsXRemoteService();
 
-    static bool HandleNewProperty(Window aWindowId,Display* aDisplay,
-                                    Time aEventTime, Atom aChangedAtom,
-                                    nsIWeakReference* aDomWindow);
-    
-    void XRemoteBaseStartup(const char *aAppName, const char *aProfileName);
+  nsGTKRemoteService() :
+    mServerWindow(nullptr) { }
 
-    void HandleCommandsFor(Window aWindowId);
-    static nsXRemoteService *sRemoteImplementation;
 private:
-    void EnsureAtoms();
-    static const char* HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
-                                         uint32_t aTimestamp);
-
-    virtual void SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
-                                                uint32_t aTimestamp) = 0;
-
-    nsCString mAppName;
-    nsCString mProfileName;
-
-    static Atom sMozVersionAtom;
-    static Atom sMozLockAtom;
-    static Atom sMozResponseAtom;
-    static Atom sMozUserAtom;
-    static Atom sMozProfileAtom;
-    static Atom sMozProgramAtom;
-    static Atom sMozCommandLineAtom;
+  ~nsGTKRemoteService() { }
+
+  void HandleCommandsFor(GtkWidget* aWidget,
+                         nsIWeakReference* aWindow);
+
+
+  static gboolean HandlePropertyChange(GtkWidget *widget,
+                                       GdkEventProperty *event,
+                                       nsIWeakReference* aThis);
+
+
+  virtual void SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
+                                              uint32_t aTimestamp) override;
+
+  nsInterfaceHashtable<nsPtrHashKey<GtkWidget>, nsIWeakReference> mWindows;
+  GtkWidget* mServerWindow;  
 };
 
-#endif // NSXREMOTESERVICE_H
+#endif // __nsGTKRemoteService_h__
-- 
2.11.0


From 3d42291271e38955afab5c3e10183a66b8d2d657 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Tue, 21 Mar 2017 12:51:54 +0900
Subject: [PATCH 05/44] Dynamically resize wl_buffer according to attached
 widget

Signed-off-by: Hiroshi Hatake <cosmo0920.oucc@gmail.com>
---
 widget/gtk/WindowSurfaceProvider.cpp |  7 +++++-
 widget/gtk/WindowSurfaceProvider.h   |  6 ++++-
 widget/gtk/WindowSurfaceWayland.cpp  | 49 ++++++++++++++++++++----------------
 widget/gtk/WindowSurfaceWayland.h    |  4 ++-
 widget/gtk/X11CompositorWidget.cpp   |  2 +-
 widget/gtk/mozcontainer.c            |  8 +++---
 widget/gtk/nsWindow.cpp              |  2 +-
 widget/gtk/nsWindow.h                |  3 +++
 8 files changed, 49 insertions(+), 32 deletions(-)

diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index d51726c00015..536bbdb027da 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -26,8 +26,11 @@ WindowSurfaceProvider::WindowSurfaceProvider()
     , mXVisual(nullptr)
     , mXDepth(0)
     , mWindowSurface(nullptr)
+#ifdef GDK_WINDOWING_WAYLAND
+    , mWidget(nullptr)
     , mWaylandDisplay(nullptr)
     , mWaylandSurface(nullptr)
+#endif
 {
 }
 
@@ -51,12 +54,14 @@ void WindowSurfaceProvider::Initialize(
 }
 #ifdef GDK_WINDOWING_WAYLAND
 void WindowSurfaceProvider::Initialize(
+      nsWindow *aWidget,
       wl_display *aWaylandDisplay,
       wl_surface *aWaylandSurface)
 {
   // We should not be initialized
   MOZ_ASSERT(!mWaylandSurface);
 
+  mWidget = aWidget;
   mWaylandDisplay = aWaylandDisplay;
   mWaylandSurface = aWaylandSurface;
   mIsX11Display = false;
@@ -98,7 +103,7 @@ WindowSurfaceProvider::CreateWindowSurface()
   } else {
     MOZ_ASSERT(mWaylandDisplay);
     LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
-    return MakeUnique<WindowSurfaceWayland>(mWaylandDisplay, mWaylandSurface);
+    return MakeUnique<WindowSurfaceWayland>(mWidget, mWaylandDisplay, mWaylandSurface);
   }
 }
 
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index 2e268ba83551..60b55ba48ef6 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -18,6 +18,8 @@
 
 #include <X11/Xlib.h> // for Window, Display, Visual, etc.
 
+class nsWindow;
+
 namespace mozilla {
 namespace widget {
 
@@ -43,7 +45,8 @@ public:
       Visual* aVisual,
       int aDepth);
 #ifdef GDK_WINDOWING_WAYLAND
-   void Initialize(wl_display *aWaylandDisplay,
+   void Initialize(nsWindow *aWidget,
+                   wl_display *aWaylandDisplay,
                    wl_surface *aWaylandSurface);
 #endif
 
@@ -71,6 +74,7 @@ private:
   int         mXDepth;
   UniquePtr<WindowSurface> mWindowSurface;
 #ifdef GDK_WINDOWING_WAYLAND
+  nsWindow*   mWidget;
   wl_display* mWaylandDisplay;
   wl_surface* mWaylandSurface;
 #endif
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index 85ff90f10189..8386ff0da484 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -31,6 +31,10 @@ GDK_WINDOWING_X11 - remove
 - is bounds.x bounds.y non-zero??
 - buffer sync - can be undamaged part unsynced?
 - GdkWidnow - show/hide -> callback, get surface and frame callback
+- optimization - give backbuffer directly when requested whole area in Lock()
+- how big is rectangle owerlap in BackBufferWayland::CopyRectangle()?
+(firefox:15155): Gdk-WARNING **: Tried to map a popup with a non-top most parent
+  - it was ok in X11
 */
 #include <assert.h>
 #include <poll.h>
@@ -230,6 +234,8 @@ BackBufferWayland::Resize(int aWidth, int aHeight)
   if (aWidth == mWidth && aHeight == mHeight)
     return true;
 
+  fprintf(stderr, "BackBufferResize, %dx%d -> %dx%d",
+          mWidth, mHeight, aWidth, aHeight);
   ReleaseBuffer();
 
   int newSize = aWidth*aHeight*BUFFER_BPP;
@@ -406,7 +412,6 @@ WindowSurfaceWayland::Init()
   wl_display_dispatch_queue(mDisplay, mQueue);
   wl_display_roundtrip_queue(mDisplay, mQueue);
 
-  wl_display_dispatch_queue(mDisplay, mQueue);
   wl_display_roundtrip_queue(mDisplay, mQueue);
 
   // We should have a valid pixel format now
@@ -420,9 +425,11 @@ WindowSurfaceWayland::Init()
                               this, &err);
 }
 
-WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
+WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
+                                           wl_display *aDisplay,
                                            wl_surface *aSurface)
-  : mSurface(aSurface)
+  : mWidget(aWidget)
+  , mSurface(aSurface)
   , mFrontBuffer(nullptr)
   , mBackBuffer(nullptr)
   , mFrameCallback(nullptr)
@@ -432,10 +439,8 @@ WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
 
   mDisplay = aDisplay;
   Init();
-  wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);
 
-  mFrameCallback = wl_surface_frame(aSurface);
-  wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+  wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);
 }
 
 WindowSurfaceWayland::~WindowSurfaceWayland()
@@ -483,18 +488,16 @@ void
 WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
 {
   gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
-  gfx::IntSize size = bounds.Size();
+  gfx::IntSize bufferSize(bounds.XMost(), bounds.YMost());
+  gfx::IntSize areaSize = bounds.Size();
 
-  fprintf(stderr, "WindowSurfaceWayland::Request %d,%d -> %d x %d\n",
-                   bounds.x, bounds.y, size.width, size.height);
-/* TODO
-  BackBufferWayland* buffer = GetBufferToDraw(bounds.x + size.width,
-                                              bounds.y + size.height);
-*/
+  fprintf(stderr, "WindowSurfaceWayland::Commit %d,%d, size %d x %d\n",
+                   bounds.x, bounds.y, bufferSize.width, bufferSize.height);
 
-  BackBufferWayland* buffer = GetBufferToDraw(1300, 1300);
-  NS_ASSERTION(buffer,
-               "******** We don't have a buffer to draw to!");
+  LayoutDeviceIntRect rect = mWidget->GetBounds();
+  BackBufferWayland* buffer = GetBufferToDraw(rect.width,
+                                              rect.height);
+  NS_ASSERTION(buffer, "We don't have any buffer to draw to!");
   if (!buffer)
     return;
 
@@ -502,15 +505,17 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
     buffer->CopyRectangle(&mImageBuffer, iter.Get());
   }
 
-  wl_surface_damage(mSurface, bounds.x, bounds.y, size.width, size.height);
-
-  fprintf(stderr, "WindowSurfaceWayland::Commit %d,%d -> %d x %d\n",
-                   bounds.x, bounds.y, size.width, size.height);
-
+  wl_surface_damage(mSurface, bounds.x, bounds.y, areaSize.width, areaSize.height);
+/*
+  if (mFrameCallback) {
+      wl_callback_destroy(mFrameCallback);
+  }
+  mFrameCallback = wl_surface_frame(mSurface);
+  wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+*/
   Draw();
 }
 
-// TODO -> why is it not called?
 void
 WindowSurfaceWayland::Draw()
 {
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
index 221a0619bf7e..3ec86ecf7c7a 100644
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -83,7 +83,7 @@ private:
 // and related management
 class WindowSurfaceWayland : public WindowSurface {
 public:
-  WindowSurfaceWayland(wl_display *aDisplay, wl_surface *aSurface);
+  WindowSurfaceWayland(nsWindow *aWidget, wl_display *aDisplay, wl_surface *aSurface);
   ~WindowSurfaceWayland();
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
@@ -109,6 +109,8 @@ private:
   static GThread*           mThread;
   static wl_display*        mDisplay;
 
+  nsWindow*                 mWidget;
+
   // The surface size is dynamically allocated by Commit() call,
   // we store the latest size request here to optimize
   // buffer usage and our gfx operations
diff --git a/widget/gtk/X11CompositorWidget.cpp b/widget/gtk/X11CompositorWidget.cpp
index ba484c934aea..eb3fe82873ca 100644
--- a/widget/gtk/X11CompositorWidget.cpp
+++ b/widget/gtk/X11CompositorWidget.cpp
@@ -52,7 +52,7 @@ X11CompositorWidget::X11CompositorWidget(const CompositorWidgetInitData& aInitDa
       );
   } else {
     mWaylandSurface = (wl_surface *)aInitData.XWindow();
-    mProvider.Initialize(mWaylandDisplay, mWaylandSurface);
+    mProvider.Initialize(aWindow, mWaylandDisplay, mWaylandSurface);
   }
 
   mClientSize = aInitData.InitialClientSize();
diff --git a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.c
index fffc5c485181..e05ca2584384 100644
--- a/widget/gtk/mozcontainer.c
+++ b/widget/gtk/mozcontainer.c
@@ -176,7 +176,6 @@ moz_container_map_wl_surface(MozContainer *container)
       // We requested the underlying wl_surface too early.
       return FALSE;
     }
-    //wl_proxy_set_queue((struct wl_proxy *)gtk_surface, mQueue);
 
     container->subsurface =
       wl_subcompositor_get_subsurface (container->subcompositor,
@@ -347,7 +346,7 @@ moz_container_unmap (GtkWidget *widget)
 #if defined(GDK_WINDOWING_WAYLAND)
   /* Gdk/Wayland deletes underlying GdkWindow wl_surface on unmap event.
    * Delete the wl_subsurface interface which
-   * keeps wl_surface object and it's available to reuse.
+   * keeps wl_surface object and it's available for reuse.
    */
     moz_container_unmap_surface(MOZ_CONTAINER(widget));
 #endif
@@ -377,14 +376,13 @@ moz_container_realize (GtkWidget *widget)
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.window_type = GDK_WINDOW_CHILD;
 #if defined(GDK_WINDOWING_WAYLAND)
-        /* TODO: We may optimize the code to use GDK_WINDOW_SUBSURFACE
-         * for all windows
-         */
+/*
         parent_widget = gtk_widget_get_parent(widget);
         if (parent_widget &&
             gtk_window_get_window_type(GTK_WINDOW(parent_widget)) == GTK_WINDOW_POPUP) {
             attributes.window_type = GDK_WINDOW_SUBSURFACE;
         }
+*/
 #endif
 
 #if (MOZ_WIDGET_GTK == 2)
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index 0555c8bdeff1..af7d1ee2006a 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -4068,7 +4068,7 @@ nsWindow::Create(nsIWidget* aParent,
     else {
       mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
       mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
-      mSurfaceProvider.Initialize(mWaylandDisplay, mWaylandSurface);
+      mSurfaceProvider.Initialize(this, mWaylandDisplay, mWaylandSurface);
     }
 #endif
 #endif
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index c1398735882a..a90387c410e0 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -23,6 +23,9 @@
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 #endif /* MOZ_X11 */
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 
 #include "mozilla/widget/WindowSurface.h"
 #include "mozilla/widget/WindowSurfaceProvider.h"
-- 
2.11.0


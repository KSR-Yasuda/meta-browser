From 6e759cf218a6ba6a2b2e316e99ef2a425a1360a5 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Tue, 21 Mar 2017 11:34:55 +0900
Subject: [PATCH 03/44] Debug version

Signed-off-by: Hiroshi Hatake <cosmo0920.oucc@gmail.com>
---
 widget/gtk/WindowSurfaceWayland.cpp | 341 +++++++++++++++++++++++++++---------
 widget/gtk/WindowSurfaceWayland.h   |  75 ++++++--
 2 files changed, 324 insertions(+), 92 deletions(-)

diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index 1622abe92a86..7fab07cfc1d3 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -27,6 +27,10 @@ GDK_WINDOWING_X11 - remove
 - resize (pool size) optimization
 - pool of available buffers?
 - call wayland display/queue events right after attach&co?
+- optimization -> use Image bufer when update area is smaller that whole window
+- is bounds.x bounds.y non-zero??
+- buffer sync - can be undamaged part unsynced?
+- GdkWidnow - show/hide -> callback, get surface and frame callback
 */
 #include <assert.h>
 #include <poll.h>
@@ -55,7 +59,72 @@ wl_event_queue*     WindowSurfaceWayland::mQueue;
 GThread*            WindowSurfaceWayland::mThread;
 wl_display*         WindowSurfaceWayland::mDisplay;
 
-bool SurfaceBuffer::CreateShmPool(int aSize)
+ImageBuffer::ImageBuffer()
+  : mBufferData(nullptr)
+  , mBufferAllocated(0)
+  , mWidth(0)
+  , mHeight(0)
+{
+}
+
+ImageBuffer::~ImageBuffer()
+{
+  if (mBufferData)
+    free(mBufferData);
+}
+
+void
+ImageBuffer::Dump(char *lokace)
+{
+  char tmp[500];
+  static int num = 0;
+  sprintf(tmp, "/home/komat/tmpmoz/check-%.3d-%s.png", num++, lokace);
+  cairo_surface_t *surface =
+    cairo_image_surface_create_for_data (mBufferData, CAIRO_FORMAT_ARGB32,
+                                         mWidth, mHeight,
+                                         mWidth * BUFFER_BPP);
+  cairo_surface_write_to_png(surface, tmp);
+  cairo_surface_destroy(surface);
+}
+
+already_AddRefed<gfx::DrawTarget>
+ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize imageSize(bounds.XMost(), bounds.YMost());
+
+  fprintf(stderr, "ImageBuffer::Lock %d,%d, size %d x %d\n",
+                   bounds.x, bounds.y, imageSize.width, imageSize.height);
+
+  // We use the same trick as nsShmImage::CreateDrawTarget() does:
+  // Due to bug 1205045, we must avoid making GTK calls off the main thread
+  // to query window size.
+  // Instead we just track the largest offset within the image we are
+  // drawing to and grow the image to accomodate it. Since usually
+  // the entire window is invalidated on the first paint to it,
+  // this should grow the image to the necessary size quickly without
+  // many intermediate reallocations.
+  int newSize = imageSize.width * imageSize.height * BUFFER_BPP;
+  if (!mBufferData || mBufferAllocated < newSize) {
+    if (mBufferData) {
+      free(mBufferData);
+    }
+
+    mBufferData = (unsigned char*)malloc(newSize);
+    if (!mBufferData)
+      return nullptr;
+
+    mBufferAllocated = newSize;
+  }
+
+  mWidth = imageSize.width;
+  mHeight = imageSize.height;
+
+  return gfxPlatform::CreateDrawTargetForData(mBufferData, imageSize,
+    BUFFER_BPP * mWidth, WindowSurfaceWayland::GetSurfaceFormat());
+}
+
+bool BackBufferWayland::CreateShmPool(int aSize)
 {
   mAllocatedSize = aSize;
 
@@ -75,11 +144,11 @@ bool SurfaceBuffer::CreateShmPool(int aSize)
                                 mShmPoolFd, mAllocatedSize);
   wl_proxy_set_queue((struct wl_proxy *)mShmPool,
                      WindowSurfaceWayland::GetQueue());
-                                
+
   return true;
 }
 
-bool SurfaceBuffer::ResizeShmPool(int aSize)
+bool BackBufferWayland::ResizeShmPool(int aSize)
 {
   // We do size increase only
   if (aSize <= mAllocatedSize)
@@ -107,7 +176,7 @@ bool SurfaceBuffer::ResizeShmPool(int aSize)
   return true;
 }
 
-void SurfaceBuffer::ReleaseShmPool()
+void BackBufferWayland::ReleaseShmPool()
 {
   munmap(mBufferData, mAllocatedSize);
   wl_shm_pool_destroy(mShmPool);
@@ -119,8 +188,8 @@ void SurfaceBuffer::ReleaseShmPool()
 
 static void
 buffer_release(void *data, wl_buffer *buffer)
-{  
-  auto surface = reinterpret_cast<SurfaceBuffer*>(data);
+{
+  auto surface = reinterpret_cast<BackBufferWayland*>(data);
   surface->Detach();
 }
 
@@ -128,7 +197,7 @@ static const struct wl_buffer_listener buffer_listener = {
   buffer_release
 };
 
-void SurfaceBuffer::CreateBuffer(int aWidth, int aHeight)
+void BackBufferWayland::CreateBuffer(int aWidth, int aHeight)
 {
   mBuffer = wl_shm_pool_create_buffer(mShmPool, 0,
                               			  aWidth, aHeight, aWidth*BUFFER_BPP,
@@ -141,21 +210,20 @@ void SurfaceBuffer::CreateBuffer(int aWidth, int aHeight)
   mHeight = aHeight;
 }
 
-void SurfaceBuffer::ReleaseBuffer()
+void BackBufferWayland::ReleaseBuffer()
 {
   wl_buffer_destroy(mBuffer);
   mWidth = mHeight = 0;
 }
 
-SurfaceBuffer::SurfaceBuffer(int aWidth, int aHeight)
+BackBufferWayland::BackBufferWayland(int aWidth, int aHeight)
  : mShmPool(nullptr)
   ,mShmPoolFd(0)
   ,mAllocatedSize(0)
   ,mBuffer(nullptr)
   ,mBufferData(nullptr)
-  ,mWidth(0)
-  ,mHeight(0)
-  ,mFormat(gfx::SurfaceFormat::B8G8R8A8)
+  ,mWidth(aWidth)
+  ,mHeight(aHeight)
   ,mAttached(false)
 {
   if(CreateShmPool(aWidth*aHeight*BUFFER_BPP)) {
@@ -164,13 +232,14 @@ SurfaceBuffer::SurfaceBuffer(int aWidth, int aHeight)
     assert(0);
 }
 
-SurfaceBuffer::~SurfaceBuffer()
+BackBufferWayland::~BackBufferWayland()
 {
   ReleaseBuffer();
   ReleaseShmPool();
 }
 
-bool SurfaceBuffer::Resize(int aWidth, int aHeight)
+bool
+BackBufferWayland::Resize(int aWidth, int aHeight)
 {
   if (aWidth == mWidth && aHeight == mHeight)
     return true;
@@ -185,53 +254,117 @@ bool SurfaceBuffer::Resize(int aWidth, int aHeight)
   return (mBuffer != nullptr);
 }
 
-already_AddRefed<gfx::DrawTarget>
-SurfaceBuffer::Lock()
+// Update back buffer with image data from ImageBuffer
+void
+BackBufferWayland::CopyRectangle(ImageBuffer *aImage,
+                                 const mozilla::LayoutDeviceIntRect &r)
 {
-  unsigned char* data = static_cast<unsigned char*>(mBufferData);
-  return gfxPlatform::CreateDrawTargetForData(data,
-                                              gfx::IntSize(mWidth, mHeight),
-                                              mWidth*BUFFER_BPP,
-                                              mFormat);
+  for (int y = r.y; y < r.y + r.height; y++) {
+    int start = (y * mWidth + r.x) * BUFFER_BPP;
+    int lenght = r.width * BUFFER_BPP;
+    memcpy((unsigned char *)mBufferData + start,
+            aImage->GetData() + ((y * aImage->mWidth) + r.x) * BUFFER_BPP,
+            lenght);
+  }
 }
 
+// Update back buffer with image data from ImageBuffer
 void
-SurfaceBuffer::Attach(wl_surface* aSurface,
-                      const LayoutDeviceIntRegion& aInvalidRegion)
+BackBufferWayland::UpdateRegion(ImageBuffer *aImage,
+                                const LayoutDeviceIntRegion& aInvalidRegion)
 {
+
+/*
   gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
-  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+  gfx::IntSize regionSize = bounds.Size();
+  assert(bounds.x + regionSize.width <= mWidth &&
+         bounds.y + regionSize.height <= mHeight);
+*/
+/*
+  for (int y = bounds.y; y < bounds.y + regionSize.height; y++) {
+    int start = (y * mWidth + bounds.x) * BUFFER_BPP;
+    int lenght = regionSize.width * BUFFER_BPP;
+    //memset((unsigned char *)mBufferData + start, c, lenght);
+    for (int i = 0; i < lenght; i+=4) {
+      ((unsigned char *)mBufferData + start)[i] = c;
+      ((unsigned char *)mBufferData + start)[i+1] = c;
+      ((unsigned char *)mBufferData + start)[i+2] = c;
+      ((unsigned char *)mBufferData + start)[i+3] = 0xff;
+    }
+  }
+*/
+  // Copy whole aImage to bounds.x, bounds.y, size.width, size.height
+/*
+  if (mWidth == size.width) {
+    // copy whole rows
+    int start = bounds.y * mWidth * BUFFER_BPP;
+    int lenght = size.height * mWidth * BUFFER_BPP;
+    memcpy((unsigned char *)mBufferData + start, aImage->GetData(), lenght);
+  } else {
+*/
+/*
 
-  fprintf(stderr, "Commit %d,%d -> %d x %d\n", bounds.x, bounds.y, size.width, size.height);
-  wl_surface_damage(aSurface, bounds.x, bounds.y, size.width, size.height);
-  wl_surface_attach(aSurface, mBuffer, 0, 0);
-  wl_surface_commit(aSurface);
+    Dump();
+*/
+/*
+    for (int y = bounds.y; y < bounds.y + regionSize.height; y++) {
+      int start = (y * mWidth + bounds.x) * BUFFER_BPP;
+      int lenght = regionSize.width * BUFFER_BPP;
+      memcpy((unsigned char *)mBufferData + start,
+              aImage->GetData() + ((y * aImage->mWidth) + bounds.x) * BUFFER_BPP,
+              lenght);
+    }
+*/
+//    Dump();
+//  }
+}
+
+void
+BackBufferWayland::Dump()
+{
+  char tmp[500];
+  static int num = 0;
+  sprintf(tmp, "/home/komat/tmpmoz/back-buffer-%.3d.png", num++);
+  cairo_surface_t *surface =
+    cairo_image_surface_create_for_data ((unsigned char *)mBufferData,
+                                         CAIRO_FORMAT_ARGB32,
+                                         mWidth, mHeight,
+                                         mWidth * BUFFER_BPP);
+  cairo_surface_write_to_png(surface, tmp);
+  cairo_surface_destroy(surface);
+}
 
+void
+BackBufferWayland::Attach(wl_surface* aSurface)
+{
   // Taken from Hybris project:
   // Some compositors, namely Weston, queue buffer release events instead
   // of sending them immediately.  If a frame event is used, this should
   // not be a problem.  Without a frame event, we need to send a sync
-  // request to ensure that they get flushed.    
+  // request to ensure that they get flushed.
   //wl_callback_destroy(wl_display_sync(WindowSurfaceWayland::GetDisplay()));
-  
-  wl_display_flush(WindowSurfaceWayland::GetDisplay());
 
+  wl_surface_attach(aSurface, mBuffer, 0, 0);
+  wl_surface_commit(aSurface);
+  wl_display_flush(WindowSurfaceWayland::GetDisplay());
   mAttached = true;
 }
 
 void
-SurfaceBuffer::Detach()
+BackBufferWayland::Detach()
 {
   mAttached = false;
 }
 
-bool SurfaceBuffer::Sync(class SurfaceBuffer* aSourceBuffer)
+bool BackBufferWayland::Sync(class BackBufferWayland* aSourceBuffer)
 {
-  if (mWidth != aSourceBuffer->mWidth || mHeight != aSourceBuffer->mHeight)
-    return false;
+  bool bufferSizeMatches = MatchSize(aSourceBuffer);
+  if (!bufferSizeMatches) {
+    Resize(aSourceBuffer->mWidth, aSourceBuffer->mHeight);
+  }
 
-  int bufferSize = mWidth*mHeight*BUFFER_BPP;
-  memcpy(mBufferData, aSourceBuffer->mBufferData, bufferSize);
+  memcpy(mBufferData, aSourceBuffer->mBufferData,
+         aSourceBuffer->mWidth * aSourceBuffer->mHeight * BUFFER_BPP);
   return true;
 }
 
@@ -293,7 +426,7 @@ gst_wl_display_thread_run (gpointer data)
 
   /* main loop */
   while (1) {
-    fprintf(stderr, "***** Loop Enter 1.\n");
+    //fprintf(stderr, "***** Loop Enter 1.\n");
     while (wl_display_prepare_read_queue (WindowSurfaceWayland::GetDisplay(),
                                           WindowSurfaceWayland::GetQueue()) < 0) {
       wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
@@ -301,16 +434,16 @@ gst_wl_display_thread_run (gpointer data)
     }
     wl_display_flush (WindowSurfaceWayland::GetDisplay());
 
-    fprintf(stderr, "***** Loop Enter 2.\n");
+    // fprintf(stderr, "***** Loop Enter 2.\n");
     int ret = poll(&fds, 1, -1);
-    fprintf(stderr, "***** Loop Enter 3.\n");
+    // fprintf(stderr, "***** Loop Enter 3.\n");
     if (ret == -1) {
       wl_display_cancel_read(WindowSurfaceWayland::GetDisplay());
-      fprintf(stderr, "***** Loop error!!\n");
+      // fprintf(stderr, "***** Loop error!!\n");
       break;
     }
     wl_display_read_events(WindowSurfaceWayland::GetDisplay());
-    wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(), 
+    wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
                                        WindowSurfaceWayland::GetQueue());
   }
 
@@ -319,6 +452,17 @@ gst_wl_display_thread_run (gpointer data)
 
 extern "C" {
 struct wl_event_queue* moz_container_get_wl_queue();
+
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time)
+{
+    auto surface = reinterpret_cast<WindowSurfaceWayland*>(data);
+    surface->Draw();
+}
+
+static const struct wl_callback_listener frame_listener = {
+    redraw
+};
 }
 
 void
@@ -328,7 +472,7 @@ WindowSurfaceWayland::Init()
   if (mInitialized)
     return;
   mInitialized = true;
-  
+
   mQueue = moz_container_get_wl_queue();
 
   // wl_shm and wl_subcompositor are not provided by Gtk so we need
@@ -337,6 +481,11 @@ WindowSurfaceWayland::Init()
   wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
   wl_registry_add_listener(registry,
                            &registry_listener, nullptr);
+
+  // We need two roundtrips here to get the registry info
+  wl_display_dispatch_queue(mDisplay, mQueue);
+  wl_display_roundtrip_queue(mDisplay, mQueue);
+
   wl_display_dispatch_queue(mDisplay, mQueue);
   wl_display_roundtrip_queue(mDisplay, mQueue);
 
@@ -344,6 +493,8 @@ WindowSurfaceWayland::Init()
   mIsAvailable = (mFormat != gfx::SurfaceFormat::UNKNOWN);
   NS_ASSERTION(mIsAvailable, "We don't have any pixel format!");
 
+  assert(mFormat != gfx::SurfaceFormat::UNKNOWN);
+
   GError *err = nullptr;
   mThread = g_thread_try_new ("GstWlDisplay", gst_wl_display_thread_run,
                               this, &err);
@@ -352,9 +503,9 @@ WindowSurfaceWayland::Init()
 WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
                                            wl_surface *aSurface)
   : mSurface(aSurface)
-  , mBuffers{nullptr, nullptr}
-  , mFrontBuffer(0)
-  , mLastBuffer(0)
+  , mFrontBuffer(nullptr)
+  , mBackBuffer(nullptr)
+  , mFrameCallback(nullptr)
 {
   NS_ASSERTION(mSurface != nullptr,
                "Missing Wayland surfaces to draw to!");
@@ -362,6 +513,9 @@ WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
   mDisplay = aDisplay;
   Init();
   wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);
+
+  mFrameCallback = wl_surface_frame(aSurface);
+  wl_callback_add_listener(mFrameCallback, &frame_listener, this);
 }
 
 WindowSurfaceWayland::~WindowSurfaceWayland()
@@ -369,56 +523,87 @@ WindowSurfaceWayland::~WindowSurfaceWayland()
   // TODO - free registry, buffers etc.
 }
 
-SurfaceBuffer*
-WindowSurfaceWayland::SetBufferToDraw(int aWidth, int aHeight)
+BackBufferWayland*
+WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
 {
-  int i;
-  for (i = 0; i < 100; i++) {
-    if (!mBuffers[i] || !mBuffers[i]->IsAttached()) {
-      mFrontBuffer = i;
-      break;
-    }
-  }
-    
-  assert(i != 100);
-  
-  if (mBuffers[mFrontBuffer] != nullptr) {
-    mBuffers[mFrontBuffer]->Resize(aWidth, aHeight);
+  if (!mFrontBuffer) {
+    mFrontBuffer = new BackBufferWayland(aWidth, aHeight);
+    mBackBuffer = new BackBufferWayland(aWidth, aHeight);
   } else {
-    mBuffers[mFrontBuffer] = new SurfaceBuffer(aWidth, aHeight);    
-  }
+    if (mFrontBuffer->IsAttached()) {
+      return nullptr; //TODO
+
+      if (mBackBuffer->IsAttached()) {
+        NS_ASSERTION(!mBackBuffer->IsAttached(), "We don't have any buffer to draw to!");
+        return nullptr;
+      }
+
+      BackBufferWayland *tmp = mFrontBuffer;
+      mFrontBuffer = mBackBuffer;
+      mBackBuffer = tmp;
 
-  fprintf(stderr, "WindowSurfaceWayland %p Take Buffer[%d] %d x %d\n", this, mFrontBuffer, aWidth, aHeight);
+      mFrontBuffer->Sync(mBackBuffer);
+    }
 
-  /*
-  // Sync last and front buffer
-  if (mFrontBuffer != mLastBuffer) {  
-    mBuffers[mFrontBuffer]->Sync(mBuffers[mLastBuffer]);
-    mLastBuffer = mFrontBuffer;
+    if (!mFrontBuffer->MatchSize(aWidth, aHeight)) {
+      mFrontBuffer->Resize(aWidth, aHeight);
+    }
   }
-  */
 
-  return mBuffers[mFrontBuffer]->IsValid() ? mBuffers[mFrontBuffer] : nullptr;
+  return mFrontBuffer;
 }
 
 already_AddRefed<gfx::DrawTarget>
 WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
 {
-  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
-  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+  return mImageBuffer.Lock(aRegion);
+}
+
+void
+WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize size = bounds.Size();
 
-  SurfaceBuffer* buffer = SetBufferToDraw(size.width, size.height);
+  fprintf(stderr, "WindowSurfaceWayland::Request %d,%d -> %d x %d\n",
+                   bounds.x, bounds.y, size.width, size.height);
+/* TODO
+  BackBufferWayland* buffer = GetBufferToDraw(bounds.x + size.width,
+                                              bounds.y + size.height);
+*/
+
+  BackBufferWayland* buffer = GetBufferToDraw(1300, 1300);
+  NS_ASSERTION(buffer,
+               "******** We don't have a buffer to draw to!");
   if (!buffer)
-    return nullptr;
+    return;
+
+  for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
+    buffer->CopyRectangle(&mImageBuffer, iter.Get());
+  }
+
+  wl_surface_damage(mSurface, bounds.x, bounds.y, size.width, size.height);
 
-  return buffer->Lock();
+  fprintf(stderr, "WindowSurfaceWayland::Commit %d,%d -> %d x %d\n",
+                   bounds.x, bounds.y, size.width, size.height);
+
+  Draw();
 }
 
+// TODO -> why is it not called?
 void
-WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+WindowSurfaceWayland::Draw()
 {
-  MOZ_ASSERT(mBuffers[mFrontBuffer], "Attempted to commit invalid surface!");  
-  mBuffers[mFrontBuffer]->Attach(mSurface, aInvalidRegion);
+/*
+  if (mFrameCallback) {
+      wl_callback_destroy(mFrameCallback);
+  }
+
+  mFrameCallback = wl_surface_frame(mSurface);
+  wl_callback_add_listener(mFrameCallback,
+                           &frame_listener, this);
+*/
+  mFrontBuffer->Attach(mSurface);
 }
 
 }  // namespace widget
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
index 8a320400280d..f2bd78e9a38a 100644
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -13,22 +13,57 @@ namespace widget {
 // We support only 32bpp formats
 #define BUFFER_BPP 4
 
+// Image surface which holds actual drawing to back buffer,
+// it is commited to BackBufferWayland
+class ImageBuffer {
+friend class BackBufferWayland;
+public:
+  ImageBuffer();
+  ~ImageBuffer();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion);
+  unsigned char* GetData() { return mBufferData; };
+
+  void Dump(char *lokace);
+
+private:
+  unsigned char*     mBufferData;
+  int                mBufferAllocated;
+  int                mWidth;
+  int                mHeight;
+};
+
 // Holds actual graphics data for wl_surface
-class SurfaceBuffer {
+class BackBufferWayland {
 public:
-  SurfaceBuffer(int aWidth, int aHeight);
-  ~SurfaceBuffer();
+  BackBufferWayland(int aWidth, int aHeight);
+  ~BackBufferWayland();
+
+  void CopyRectangle(ImageBuffer *aImage,
+                     const mozilla::LayoutDeviceIntRect &r);
 
-  void Attach(wl_surface* aSurface,
-              const LayoutDeviceIntRegion& aInvalidRegion);
+  void Attach(wl_surface* aSurface);
   void Detach();
   bool IsAttached() { return mAttached; }
-  bool IsValid()    { return mBuffer && mBufferData; }
 
   bool Resize(int aWidth, int aHeight);
-  bool Sync(class SurfaceBuffer* aSourceBuffer);
-  
-  already_AddRefed<gfx::DrawTarget> Lock();
+  bool Sync(class BackBufferWayland* aSourceBuffer);
+
+  bool MatchSize(int aWidth, int aHeight)
+  {
+    return aWidth == mWidth && aHeight == mHeight;
+  }
+  bool MatchSize(class BackBufferWayland *aBuffer)
+  {
+    return aBuffer->mWidth == mWidth && aBuffer->mHeight == mHeight;
+  }
+
+  bool MatchAllocatedSize(int aSize)
+  {
+    return aSize <= mAllocatedSize;
+  }
+
+  void Dump();
 
 private:
   bool CreateShmPool(int aSize);
@@ -45,10 +80,11 @@ private:
   void*              mBufferData;
   int                mWidth;
   int                mHeight;
-  gfx::SurfaceFormat mFormat;
   bool               mAttached;
 };
 
+// WindowSurfaceWayland is an abstraction for wl_surface
+// and related management
 class WindowSurfaceWayland : public WindowSurface {
 public:
   WindowSurfaceWayland(wl_display *aDisplay, wl_surface *aSurface);
@@ -56,15 +92,17 @@ public:
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
   void                      Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
+  void                      Draw();
 
   static void               SetShm(wl_shm* aShm) { mShm = aShm; };
   static wl_shm*            GetShm() { return(mShm); };
   static wl_event_queue*    GetQueue() { return mQueue; };
   static wl_display*        GetDisplay() { return mDisplay; };
   static void               SetWaylandPixelFormat(uint32_t format);
+  static gfx::SurfaceFormat GetSurfaceFormat() { return mFormat; };
 
 private:
-  SurfaceBuffer*            SetBufferToDraw(int aWidth, int aHeight);
+  BackBufferWayland*        GetBufferToDraw(int aWidth, int aHeight);
   void                      Init();
 
   static bool               mIsAvailable;
@@ -74,10 +112,19 @@ private:
   static wl_event_queue*    mQueue;
   static GThread*           mThread;
   static wl_display*        mDisplay;
+
+  // The surface size is dynamically allocated by Commit() call,
+  // we store the latest size request here to optimize
+  // buffer usage and our gfx operations
   wl_surface*               mSurface;
-  SurfaceBuffer*            mBuffers[100];
-  int                       mFrontBuffer;
-  int                       mLastBuffer;
+  int                       mWidth;
+  int                       mHeight;
+
+  ImageBuffer               mImageBuffer;
+
+  BackBufferWayland*        mFrontBuffer;
+  BackBufferWayland*        mBackBuffer;
+  wl_callback*              mFrameCallback;
 };
 
 }  // namespace widget
-- 
2.11.0


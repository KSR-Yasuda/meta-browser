From 53e005729ff7c813f5ac529b4a4373ccaffbf64e Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Tue, 9 May 2017 13:51:32 +0200
Subject: [PATCH 1/3] Reworked multi-thread rendering code - provided
 nsWaylandDisplay for each thread which is using wayland and make that code
 thread safe

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 widget/gtk/WindowSurfaceProvider.cpp |  17 +--
 widget/gtk/WindowSurfaceProvider.h   |   6 +-
 widget/gtk/WindowSurfaceWayland.cpp  | 289 ++++++++++++++++++++++-------------
 widget/gtk/WindowSurfaceWayland.h    |  28 ++--
 widget/gtk/X11CompositorWidget.cpp   |  24 ++-
 widget/gtk/X11CompositorWidget.h     |   5 -
 widget/gtk/mozcontainer.c            |  12 +-
 widget/gtk/nsWindow.cpp              |  79 +++++++---
 widget/gtk/nsWindow.h                |   7 +-
 9 files changed, 281 insertions(+), 186 deletions(-)

diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index 251a826641b3..e3f848e27641 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -30,8 +30,6 @@ WindowSurfaceProvider::WindowSurfaceProvider()
     , mWindowSurface(nullptr)
 #ifdef MOZ_WAYLAND
     , mWidget(nullptr)
-    , mWaylandDisplay(nullptr)
-    , mWaylandSurface(nullptr)
 #endif
 {
 }
@@ -56,18 +54,10 @@ void WindowSurfaceProvider::Initialize(
 }
 
 #ifdef MOZ_WAYLAND
-void WindowSurfaceProvider::Initialize(
-      nsWindow *aWidget,
-      wl_display *aWaylandDisplay,
-      wl_surface *aWaylandSurface)
+void WindowSurfaceProvider::Initialize(nsWindow *aWidget)
 {
-  // We should not be initialized
-  MOZ_ASSERT(!mWaylandSurface);
-
   mWidget = aWidget;
-  mWaylandDisplay = aWaylandDisplay;
-  mWaylandSurface = aWaylandSurface;
-  mIsX11Display = false;
+  mIsX11Display = aWidget->IsX11Display();
 }
 #endif
 
@@ -81,9 +71,8 @@ WindowSurfaceProvider::CreateWindowSurface()
 {
 #ifdef MOZ_WAYLAND
   if (!mIsX11Display) {
-    MOZ_ASSERT(mWaylandDisplay);
     LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
-    return MakeUnique<WindowSurfaceWayland>(mWidget, mWaylandDisplay, mWaylandSurface);
+    return MakeUnique<WindowSurfaceWayland>(mWidget);
   } else
 #endif
   {
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index 8efb1efb4227..ef03a54bd25d 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -46,9 +46,7 @@ public:
       int aDepth);
 
 #ifdef MOZ_WAYLAND
-   void Initialize(nsWindow *aWidget,
-                   wl_display *aWaylandDisplay,
-                   wl_surface *aWaylandSurface);
+   void Initialize(nsWindow *aWidget);
 #endif
 
   /**
@@ -76,8 +74,6 @@ private:
   UniquePtr<WindowSurface> mWindowSurface;
 #ifdef MOZ_WAYLAND
   nsWindow*   mWidget;
-  wl_display* mWaylandDisplay;
-  wl_surface* mWaylandSurface;
 #endif
 };
 
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index ed8c2380aca8..55f1e0b040d2 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -13,75 +13,112 @@
 #include "mozilla/gfx/Tools.h"
 #include "gfxPlatform.h"
 #include "mozcontainer.h"
+#include "nsCOMArray.h"
+#include "mozilla/StaticMutex.h"
 
 #include <gdk/gdkwayland.h>
 #include <sys/mman.h>
-#include <fcntl.h>
 #include <assert.h>
-#include <poll.h>
+#include <fcntl.h>
 
 namespace mozilla {
 namespace widget {
 
-static nsWaylandDisplay* gWaylandDisplay = nullptr;
+static nsCOMArray<nsWaylandDisplay> gWaylandDisplays;
+static StaticMutex gWaylandDisplaysMutex;
 
-static void
-WaylandDisplayAddRef(wl_display *aDisplay)
+// Each thread which is using wayland connection (wl_display) has to operate
+// its own wl_event_queue on it while main thread is handled by Gtk main loop.
+// nsWaylandDisplay is our interface to wayland server, it provides wayland
+// global objects we need (wl_display, wl_shm) and operates wl_event_queue on
+// compositor thread.
+
+static nsWaylandDisplay* WaylandDisplayGet(wl_display *aDisplay);
+static void WaylandDisplayRelease(nsWaylandDisplay *aWaylandDisplay);
+static void WaylandDisplayLoop(void *aDisplay);
+
+// Get WaylandDisplay for given wl_display and actual calling thread.
+static nsWaylandDisplay*
+WaylandDisplayGetLocked(wl_display *aDisplay, const StaticMutexAutoLock&)
 {
-  // We should run in Compositor thread
-  MOZ_ASSERT(!NS_IsMainThread());
-  if (!gWaylandDisplay) {
-    gWaylandDisplay = new nsWaylandDisplay(aDisplay);
-  } else {
-    MOZ_ASSERT(gWaylandDisplay->GetDisplay() == aDisplay,
-               "Unknown Wayland display!");
+  nsWaylandDisplay* waylandDisplay = nullptr;
+
+  int len = gWaylandDisplays.Count();
+  for (int i = 0; i < len; i++) {
+    if (gWaylandDisplays[i]->Matches(aDisplay)) {
+      waylandDisplay = gWaylandDisplays[i];
+      break;
+    }
   }
-  NS_ADDREF(gWaylandDisplay);
+
+  if (!waylandDisplay) {
+    waylandDisplay = new nsWaylandDisplay(aDisplay);
+    gWaylandDisplays.AppendObject(waylandDisplay);
+  }
+
+  NS_ADDREF(waylandDisplay);
+  return waylandDisplay;
 }
 
-static void
-WaylandDisplayRelease(void *aUnused)
+static nsWaylandDisplay*
+WaylandDisplayGet(wl_display *aDisplay)
 {
-  MOZ_ASSERT(!NS_IsMainThread());
-  NS_IF_RELEASE(gWaylandDisplay);
+  StaticMutexAutoLock lock(gWaylandDisplaysMutex);
+  return WaylandDisplayGetLocked(aDisplay, lock);
 }
 
 static void
-WaylandDisplayLoop(void *tmp)
+WaylandDisplayReleaseLocked(nsWaylandDisplay *aWaylandDisplay,
+                            const StaticMutexAutoLock&)
 {
-  MOZ_ASSERT(!NS_IsMainThread());
-
-  // Check we still have the display interface
-  if (gWaylandDisplay && gWaylandDisplay->DisplayLoop()) {
-    MessageLoop::current()->PostTask(
-        NewRunnableFunction(&WaylandDisplayLoop, nullptr));
+  int len = gWaylandDisplays.Count();
+  for (int i = 0; i < len; i++) {
+    if (gWaylandDisplays[i] == aWaylandDisplay) {
+      // Check we're releasing in the same thread
+      // as WaylandDisplay was created.
+      MOZ_ASSERT(gWaylandDisplays[i]->MatchesThread());
+
+      int rc = gWaylandDisplays[i]->Release();
+      // nsCOMArray::AppendObject()/RemoveObjectAt() also call AddRef()/Release()
+      // so remove WaylandDisplay when ref count is 1.
+      if (rc == 1) {
+        gWaylandDisplays.RemoveObjectAt(i);
+      }
+      break;
+    }
   }
 }
 
-void
-nsWaylandDisplay::SetWaylandPixelFormat(uint32_t format)
+static void
+WaylandDisplayRelease(nsWaylandDisplay *aWaylandDisplay)
 {
-  switch (format) {
-    case WL_SHM_FORMAT_ARGB8888:
-      mFormat = gfx::SurfaceFormat::B8G8R8A8;
-      break;
-    case WL_SHM_FORMAT_XRGB8888:
-      // TODO - We can use non-alpha formats when we need that
-    default:
+  StaticMutexAutoLock lock(gWaylandDisplaysMutex);
+  WaylandDisplayReleaseLocked(aWaylandDisplay, lock);
+}
+
+static void
+WaylandDisplayLoopLocked(void *aDisplay,
+                         const StaticMutexAutoLock&)
+{
+  int len = gWaylandDisplays.Count();
+  for (int i = 0; i < len; i++) {
+    if (gWaylandDisplays[i]->Matches(static_cast<wl_display *>(aDisplay))) {
+      if (gWaylandDisplays[i]->DisplayLoop()) {
+        MessageLoop::current()->PostTask(
+            NewRunnableFunction(&WaylandDisplayLoop, aDisplay));
+      }
       break;
+    }
   }
 }
 
 static void
-shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+WaylandDisplayLoop(void *aDisplay)
 {
-  auto interface = reinterpret_cast<nsWaylandDisplay *>(data);
-  interface->SetWaylandPixelFormat(format);
- }
-
-struct wl_shm_listener shm_listener = {
-  shm_format
-};
+  MOZ_ASSERT(!NS_IsMainThread());
+  StaticMutexAutoLock lock(gWaylandDisplaysMutex);
+  WaylandDisplayLoopLocked(aDisplay, lock);
+}
 
 static void
 global_registry_handler(void *data, wl_registry *registry, uint32_t id,
@@ -92,7 +129,6 @@ global_registry_handler(void *data, wl_registry *registry, uint32_t id,
     auto shm = static_cast<wl_shm*>(
         wl_registry_bind(registry, id, &wl_shm_interface, 1));
     wl_proxy_set_queue((struct wl_proxy *)shm, interface->GetEventQueue());
-    wl_shm_add_listener(shm, &shm_listener, data);
     interface->SetShm(shm);
   }
 }
@@ -107,6 +143,37 @@ static const struct wl_registry_listener registry_listener = {
   global_registry_remover
 };
 
+wl_event_queue*
+nsWaylandDisplay::GetEventQueue()
+{
+  return mEventQueue;
+}
+
+wl_shm*
+nsWaylandDisplay::GetShm()
+{
+  MOZ_ASSERT(mThreadId == PR_GetCurrentThread());
+
+  // wl_shm is not provided by Gtk so we need to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);
+  wl_registry_add_listener(registry, &registry_listener, this);
+
+  if (mEventQueue) {
+    wl_proxy_set_queue((struct wl_proxy *)registry, mEventQueue);
+    // We need two roundtrips here to get the registry info
+    wl_display_dispatch_queue(mDisplay, mEventQueue);
+    wl_display_roundtrip_queue(mDisplay, mEventQueue);
+    wl_display_roundtrip_queue(mDisplay, mEventQueue);
+  } else {
+    wl_display_dispatch(mDisplay);
+    wl_display_roundtrip(mDisplay);
+    wl_display_roundtrip(mDisplay);
+  }
+
+  MOZ_RELEASE_ASSERT(mShm, "Wayland registry query failed!");
+  return(mShm);
+}
+
 bool
 nsWaylandDisplay::DisplayLoop()
 {
@@ -120,40 +187,48 @@ nsWaylandDisplay::DisplayLoop()
   return wl_display_roundtrip_queue(mDisplay, mEventQueue) != -1;
 }
 
-NS_IMPL_ISUPPORTS(nsWaylandDisplay, nsISupports);
-
-nsWaylandDisplay::nsWaylandDisplay(wl_display *aDisplay)
-  : mDisplay(aDisplay)
+bool
+nsWaylandDisplay::Matches(wl_display *aDisplay)
 {
-  // We're supposed to run in Compositor thread
-  MOZ_ASSERT(!NS_IsMainThread());
+  return mThreadId == PR_GetCurrentThread() && aDisplay == mDisplay;
+}
 
-  mEventQueue = wl_display_create_queue(mDisplay);
+#ifdef DEBUG
+bool
+nsWaylandDisplay::MatchesThread()
+{
+  return mThreadId == PR_GetCurrentThread();
+}
+#endif
 
-  // wl_shm and wl_subcompositor are not provided by Gtk so we need
-  // to query wayland directly
-  wl_registry* registry = wl_display_get_registry(mDisplay);
-  wl_proxy_set_queue((struct wl_proxy *)registry, mEventQueue);
-  wl_registry_add_listener(registry, &registry_listener, this);
+NS_IMPL_ISUPPORTS(nsWaylandDisplay, nsISupports);
 
-  // We need two roundtrips here to get the registry info
-  wl_display_dispatch_queue(mDisplay, mEventQueue);
-  wl_display_roundtrip_queue(mDisplay, mEventQueue);
-  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+nsWaylandDisplay::nsWaylandDisplay(wl_display *aDisplay)
+{
+  mThreadId = PR_GetCurrentThread();
+  mDisplay = aDisplay;
 
-  // We must have a valid pixel format
-  MOZ_RELEASE_ASSERT(mFormat != gfx::SurfaceFormat::UNKNOWN,
-                     "We don't have any pixel format!");
+  // gfx::SurfaceFormat::B8G8R8A8 is a basic Wayland format
+  // and should be always present.
+  mFormat = gfx::SurfaceFormat::B8G8R8A8;
 
-  // TODO - is that correct way how to run wayland event pump?
-  MessageLoop::current()->PostTask(NewRunnableFunction(&WaylandDisplayLoop, nullptr));
+  if (NS_IsMainThread()) {
+    // Use default event queue in main thread operated by Gtk.
+    mEventQueue = nullptr;
+  } else {
+    mEventQueue = wl_display_create_queue(mDisplay);
+    MessageLoop::current()->PostTask(NewRunnableFunction(&WaylandDisplayLoop,
+                                                         mDisplay));
+  }
 }
 
 nsWaylandDisplay::~nsWaylandDisplay()
 {
-  MOZ_ASSERT(!NS_IsMainThread());
-  wl_event_queue_destroy(mEventQueue);
-  mEventQueue = nullptr;
+  MOZ_ASSERT(mThreadId == PR_GetCurrentThread());
+  if (mEventQueue) {
+    wl_event_queue_destroy(mEventQueue);
+    mEventQueue = nullptr;
+  }
   mDisplay = nullptr;
 }
 
@@ -195,7 +270,7 @@ WaylandShmPool::CreateTemporaryFile(int aSize)
   return fd;
 }
 
-WaylandShmPool::WaylandShmPool(bool aIsMainThread, int aSize)
+WaylandShmPool::WaylandShmPool(nsWaylandDisplay* aDisplay, int aSize)
 {
   mAllocatedSize = aSize;
 
@@ -205,12 +280,9 @@ WaylandShmPool::WaylandShmPool(bool aIsMainThread, int aSize)
   MOZ_RELEASE_ASSERT(mImageData != MAP_FAILED,
                      "Unable to map drawing surface!");
 
-  mShmPool = wl_shm_create_pool(gWaylandDisplay->GetShm(),
+  mShmPool = wl_shm_create_pool(aDisplay->GetShm(),
                                 mShmPoolFd, mAllocatedSize);
-  if (!aIsMainThread) {
-    wl_proxy_set_queue((struct wl_proxy *)mShmPool,
-                      gWaylandDisplay->GetEventQueue());
-  }
+  wl_proxy_set_queue((struct wl_proxy *)mShmPool, aDisplay->GetEventQueue());
 }
 
 bool
@@ -270,10 +342,7 @@ void WindowBackBuffer::Create(int aWidth, int aHeight)
   mWaylandBuffer = wl_shm_pool_create_buffer(mShmPool.GetShmPool(), 0,
                                             aWidth, aHeight, aWidth*BUFFER_BPP,
                                             WL_SHM_FORMAT_ARGB8888);
-  if (!mIsMainThread) {
-    wl_proxy_set_queue((struct wl_proxy *)mWaylandBuffer,
-                      gWaylandDisplay->GetEventQueue());
-  }
+  wl_proxy_set_queue((struct wl_proxy *)mWaylandBuffer, mDisplay->GetEventQueue());
   wl_buffer_add_listener(mWaylandBuffer, &buffer_listener, this);
 
   mWidth = aWidth;
@@ -286,13 +355,13 @@ void WindowBackBuffer::Release()
   mWidth = mHeight = 0;
 }
 
-WindowBackBuffer::WindowBackBuffer(bool aIsMainThread, int aWidth, int aHeight)
- : mShmPool(aIsMainThread, aWidth*aHeight*BUFFER_BPP)
+WindowBackBuffer::WindowBackBuffer(nsWaylandDisplay* aDisplay, int aWidth, int aHeight)
+ : mShmPool(aDisplay, aWidth*aHeight*BUFFER_BPP)
   ,mWaylandBuffer(nullptr)
   ,mWidth(aWidth)
   ,mHeight(aHeight)
   ,mAttached(false)
-  ,mIsMainThread(aIsMainThread)
+  ,mDisplay(aDisplay)
 {
   Create(aWidth, aHeight);
 }
@@ -319,7 +388,7 @@ WindowBackBuffer::Attach(wl_surface* aSurface)
 {
   wl_surface_attach(aSurface, mWaylandBuffer, 0, 0);
   wl_surface_commit(aSurface);
-  wl_display_flush(gWaylandDisplay->GetDisplay());
+  wl_display_flush(mDisplay->GetDisplay());
   mAttached = true;
 }
 
@@ -350,7 +419,7 @@ WindowBackBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
   return gfxPlatform::CreateDrawTargetForData(static_cast<unsigned char*>(mShmPool.GetImageData()),
                                               lockSize,
                                               BUFFER_BPP * mWidth,
-                                              gWaylandDisplay->GetSurfaceFormat());
+                                              mDisplay->GetSurfaceFormat());
 }
 
 static void
@@ -364,29 +433,17 @@ static const struct wl_callback_listener frame_listener = {
     frame_callback_handler
 };
 
-WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
-                                           wl_display *aDisplay,
-                                           wl_surface *aSurface)
+WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget)
   : mWidget(aWidget)
-  , mSurface(aSurface)
+  , mDisplay(WaylandDisplayGet(aWidget->GetWaylandDisplay()))
   , mFrontBuffer(nullptr)
   , mBackBuffer(nullptr)
   , mFrameCallback(nullptr)
   , mDelayedCommit(false)
   , mFullScreenDamage(false)
-  , mWaylandMessageLoop(nullptr)
+  , mWaylandMessageLoop(MessageLoop::current())
   , mIsMainThread(NS_IsMainThread())
 {
-  MOZ_RELEASE_ASSERT(mSurface != nullptr,
-                    "We can't do anything useful without valid wl_surface.");
-
-  if (!mIsMainThread) {
-    // Register and run wayland loop when running in compositor thread.
-    mWaylandMessageLoop = MessageLoop::current();
-    WaylandDisplayAddRef(aDisplay);
-    wl_proxy_set_queue((struct wl_proxy *)mSurface,
-                       gWaylandDisplay->GetEventQueue());
-  }
 }
 
 WindowSurfaceWayland::~WindowSurfaceWayland()
@@ -399,9 +456,13 @@ WindowSurfaceWayland::~WindowSurfaceWayland()
   }
 
   if (!mIsMainThread) {
-    // Release WaylandDisplay only for surfaces created in Compositor thread.
+    // We can be destroyed from main thread even though we was created/used
+    // in compositor thread. We have to unref/delete WaylandDisplay in compositor
+    // thread then.
     mWaylandMessageLoop->PostTask(
-      NewRunnableFunction(&WaylandDisplayRelease, nullptr));
+      NewRunnableFunction(&WaylandDisplayRelease, mDisplay));
+  } else {
+    WaylandDisplayRelease(mDisplay);
   }
 }
 
@@ -409,8 +470,8 @@ WindowBackBuffer*
 WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
 {
   if (!mFrontBuffer) {
-    mFrontBuffer = new WindowBackBuffer(mIsMainThread, aWidth, aHeight);
-    mBackBuffer = new WindowBackBuffer(mIsMainThread, aWidth, aHeight);
+    mFrontBuffer = new WindowBackBuffer(mDisplay, aWidth, aHeight);
+    mBackBuffer = new WindowBackBuffer(mDisplay, aWidth, aHeight);
     return mFrontBuffer;
   }
 
@@ -474,15 +535,23 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
 {
   MOZ_ASSERT(mIsMainThread == NS_IsMainThread());
 
+  wl_surface* waylandSurface = mWidget->GetWaylandSurface();
+  if (!waylandSurface) {
+    // Target window is already destroyed - don't bother to render there.
+    return;
+  }
+  wl_proxy_set_queue((struct wl_proxy *)waylandSurface,
+                     mDisplay->GetEventQueue());
+
   for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
     const mozilla::LayoutDeviceIntRect &r = iter.Get();
     if (!mFullScreenDamage)
-      wl_surface_damage(mSurface, r.x, r.y, r.width, r.height);
+      wl_surface_damage(waylandSurface, r.x, r.y, r.width, r.height);
   }
 
   if (mFullScreenDamage) {
     LayoutDeviceIntRect rect = mWidget->GetBounds();
-    wl_surface_damage(mSurface, 0, 0, rect.width, rect.height);
+    wl_surface_damage(waylandSurface, 0, 0, rect.width, rect.height);
     mFullScreenDamage = false;
   }
 
@@ -492,12 +561,12 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
     mDelayedCommit = true;
     return;
   } else  {
-    mFrameCallback = wl_surface_frame(mSurface);
+    mFrameCallback = wl_surface_frame(waylandSurface);
     wl_callback_add_listener(mFrameCallback, &frame_listener, this);
 
     // There's no pending frame callback so we can draw immediately
     // and create frame callback for possible subsequent drawing.
-    mFrontBuffer->Attach(mSurface);
+    mFrontBuffer->Attach(waylandSurface);
     mDelayedCommit = false;
   }
 }
@@ -513,12 +582,20 @@ WindowSurfaceWayland::FrameCallbackHandler()
   }
 
   if (mDelayedCommit) {
+    wl_surface* waylandSurface = mWidget->GetWaylandSurface();
+    if (!waylandSurface) {
+      // Target window is already destroyed - don't bother to render there.
+      return;
+    }
+    wl_proxy_set_queue((struct wl_proxy *)waylandSurface,
+                       mDisplay->GetEventQueue());
+
     // Send pending surface to compositor and register frame callback
     // for possible subsequent drawing.
-    mFrameCallback = wl_surface_frame(mSurface);
+    mFrameCallback = wl_surface_frame(waylandSurface);
     wl_callback_add_listener(mFrameCallback, &frame_listener, this);
 
-    mFrontBuffer->Attach(mSurface);
+    mFrontBuffer->Attach(waylandSurface);
     mDelayedCommit = false;
   }
 }
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
index 45e523a16ef4..a88fa40be6e5 100644
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -7,6 +7,8 @@
 #ifndef _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
 #define _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
 
+#include <prthread.h>
+
 namespace mozilla {
 namespace widget {
 
@@ -21,17 +23,22 @@ class nsWaylandDisplay : public nsISupports {
 public:
   nsWaylandDisplay(wl_display *aDisplay);
 
+  wl_shm*             GetShm();
+  wl_event_queue*     GetEventQueue();
+
   void                SetShm(wl_shm* aShm)   { mShm = aShm; };
-  wl_shm*             GetShm()               { return(mShm); };
-  wl_event_queue*     GetEventQueue()        { return mEventQueue; };
   wl_display*         GetDisplay()           { return mDisplay; };
   gfx::SurfaceFormat  GetSurfaceFormat()     { return mFormat; };
-  void                SetWaylandPixelFormat(uint32_t format);
   bool                DisplayLoop();
+  bool                Matches(wl_display *aDisplay);
+#ifdef DEBUG
+  bool                MatchesThread();
+#endif
 
 private:
   virtual ~nsWaylandDisplay();
 
+  PRThread*           mThreadId;
   gfx::SurfaceFormat  mFormat;
   wl_shm*             mShm;
   wl_event_queue*     mEventQueue;
@@ -41,7 +48,7 @@ private:
 // Allocates and owns shared memory for Wayland drawing surfaces
 class WaylandShmPool {
 public:
-  WaylandShmPool(bool aIsMainThread, int aSize);
+  WaylandShmPool(nsWaylandDisplay* aDisplay, int aSize);
   ~WaylandShmPool();
 
   bool                Resize(int aSize);
@@ -60,7 +67,7 @@ private:
 // Holds actual graphics data for wl_surface
 class WindowBackBuffer {
 public:
-  WindowBackBuffer(bool aIsMainThread, int aWidth, int aHeight);
+  WindowBackBuffer(nsWaylandDisplay* aDisplay, int aWidth, int aHeight);
   ~WindowBackBuffer();
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion);
@@ -94,14 +101,14 @@ private:
   int                 mWidth;
   int                 mHeight;
   bool                mAttached;
-  bool                mIsMainThread;
+  nsWaylandDisplay*   mDisplay;
 };
 
 // WindowSurfaceWayland is an abstraction for wl_surface
 // and related management
 class WindowSurfaceWayland : public WindowSurface {
 public:
-  WindowSurfaceWayland(nsWindow *aWidget, wl_display *aDisplay, wl_surface *aSurface);
+  WindowSurfaceWayland(nsWindow *aWidget);
   ~WindowSurfaceWayland();
 
   already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
@@ -112,12 +119,7 @@ private:
   WindowBackBuffer*         GetBufferToDraw(int aWidth, int aHeight);
 
   nsWindow*                 mWidget;
-
-  // The surface size is dynamically allocated by Commit() call,
-  // we store the latest size request here to optimize
-  // buffer usage and our gfx operations
-  wl_surface*               mSurface;
-
+  nsWaylandDisplay*         mDisplay;
   WindowBackBuffer*         mFrontBuffer;
   WindowBackBuffer*         mBackBuffer;
   wl_callback*              mFrameCallback;
diff --git a/widget/gtk/X11CompositorWidget.cpp b/widget/gtk/X11CompositorWidget.cpp
index b5cc9112cd4b..c7d72be24229 100644
--- a/widget/gtk/X11CompositorWidget.cpp
+++ b/widget/gtk/X11CompositorWidget.cpp
@@ -21,27 +21,21 @@ X11CompositorWidget::X11CompositorWidget(const CompositorWidgetInitData& aInitDa
   // If we have a nsWindow, then grab the already existing display connection
   // If we don't, then use the init data to connect to the display
   if (aWindow) {
-    mIsX11Display = aWindow->IsX11Display();
-#ifdef MOZ_WAYLAND
-    if (!mIsX11Display) {
-      mWaylandDisplay = aWindow->WaylandDisplay();
-	} else
-#endif
-	{
-      mXDisplay = aWindow->XDisplay();
-    }
+    mXDisplay = aWindow->XDisplay();
   } else {
+    mXDisplay = XOpenDisplay(aInitData.XDisplayString().get());
 #ifdef MOZ_WAYLAND
-    // TODO - not implemented
-    MOZ_CRASH();
+    if (!mXDisplay) {
+      // TODO - not implemented
+      MOZ_CRASH();
+    }
 #endif
-    mXDisplay = XOpenDisplay(aInitData.XDisplayString().get());
   }
 
 #ifdef MOZ_WAYLAND
-  if (!mIsX11Display) {
-    mWaylandSurface = (wl_surface *)aInitData.XWindow();
-    mProvider.Initialize(aWindow, mWaylandDisplay, mWaylandSurface);
+  if (!mXDisplay) {
+    MOZ_ASSERT(aWindow);
+    mProvider.Initialize(aWindow);
   } else
 #endif
   {
diff --git a/widget/gtk/X11CompositorWidget.h b/widget/gtk/X11CompositorWidget.h
index a80e4221bc5e..c0e0edeb3351 100644
--- a/widget/gtk/X11CompositorWidget.h
+++ b/widget/gtk/X11CompositorWidget.h
@@ -58,13 +58,8 @@ protected:
 private:
   LayoutDeviceIntSize mClientSize;
 
-  bool     mIsX11Display;
   Display* mXDisplay;
   Window   mXWindow;
-#ifdef MOZ_WAYLAND
-  wl_display* mWaylandDisplay;
-  wl_surface* mWaylandSurface;
-#endif
   WindowSurfaceProvider mProvider;
 };
 
diff --git a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.c
index c047a39a3e60..d88b58ed343f 100644
--- a/widget/gtk/mozcontainer.c
+++ b/widget/gtk/mozcontainer.c
@@ -157,7 +157,7 @@ moz_container_move (MozContainer *container, GtkWidget *child_widget,
  * and gdk_wayland_window_get_wl_surface() fails.
  */
 gboolean
-moz_container_map_wl_surface(MozContainer *container)
+moz_container_map_surface(MozContainer *container)
 {
     GdkDisplay *display;
     struct wl_compositor *compositor;
@@ -197,6 +197,7 @@ static void
 moz_container_unmap_surface(MozContainer *container)
 {
     g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
+    g_clear_pointer(&container->surface, wl_surface_destroy);
 }
 
 static void
@@ -321,6 +322,10 @@ moz_container_map (GtkWidget *widget)
     if (gtk_widget_get_has_window (widget)) {
         gdk_window_show (gtk_widget_get_window(widget));
     }
+#if defined(MOZ_WAYLAND)
+    moz_container_create_surface(MOZ_CONTAINER(widget));
+    moz_container_map_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
 void
@@ -376,7 +381,7 @@ moz_container_realize (GtkWidget *widget)
         parent_widget = gtk_widget_get_parent(widget);
         if (parent_widget &&
             gtk_window_get_window_type(GTK_WINDOW(parent_widget)) == GTK_WINDOW_POPUP) {
-            //attributes.window_type = GDK_WINDOW_SUBSURFACE;
+            //attributes.window_type = GDK_WINDOW_TEMP;
         }
 #endif
         window = gdk_window_new (parent, &attributes, attributes_mask);
@@ -398,7 +403,7 @@ moz_container_realize (GtkWidget *widget)
     widget->style = gtk_style_attach (widget->style, widget->window);
 #endif
 #if defined(MOZ_WAYLAND)
-    moz_container_create_surface(MOZ_CONTAINER(widget));
+//    moz_container_create_surface(MOZ_CONTAINER(widget));
 #endif
 }
 
@@ -583,6 +588,7 @@ moz_container_add(GtkContainer *container, GtkWidget *widget)
 struct wl_surface*
 moz_container_get_wl_surface(MozContainer *container)
 {
+    // TODO -> map
     return container->surface;
 }
 #endif
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index f9f6bdad6d86..bf68d7604dae 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -463,9 +463,6 @@ nsWindow::nsWindow()
     mXDepth   = 0;
 #endif /* MOZ_X11 */
     mPluginType          = PluginType_NONE;
-#ifdef MOZ_WAYLAND
-    mWaylandSurface = nullptr;
-#endif
 
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = true;
@@ -1739,18 +1736,28 @@ nsWindow::GetNativeData(uint32_t aDataType)
         return mGdkWindow;
     }
     case NS_NATIVE_PLUGIN_PORT:
-        if (!mWaylandDisplay) {
+#if defined(MOZ_WAYLAND)
+        if (!GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             return SetupPluginPort();
         }
+#else
+        return SetupPluginPort();
+#endif
     case NS_NATIVE_PLUGIN_ID:
-        if (!mWaylandDisplay) {
+#if defined(MOZ_WAYLAND)
+        if (!GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             if (!mPluginNativeWindow) {
                 NS_WARNING("no native plugin instance!");
                 return nullptr;
             }
-            // Return the socket widget XID
-            return (void*)mPluginNativeWindow->window;
         }
+#else
+        if (!mPluginNativeWindow) {
+            NS_WARNING("no native plugin instance!");
+            return nullptr;
+        }
+#endif
+        return (void*)mPluginNativeWindow->window;
     case NS_NATIVE_DISPLAY: {
 #if defined(MOZ_X11)
         GdkDisplay* gdkDisplay = gdk_display_get_default();
@@ -2156,12 +2163,6 @@ nsWindow::OnExposeEvent(cairo_t *cr)
     if (!listener)
         return FALSE;
 
-#ifdef MOZ_WAYLAND
-    // We don't have any Wayland surface to paint to
-    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
-        return FALSE;
-#endif
-
     LayoutDeviceIntRegion exposeRegion;
 #if (MOZ_WIDGET_GTK == 2)
     if (!ExtractExposeRegion(exposeRegion, aEvent)) {
@@ -3771,7 +3772,9 @@ nsWindow::Create(nsIWidget* aParent,
                         gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
                         break;
                     default:
-                        gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+                        gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
+                        //gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
+                        //gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
                         break;
                 }
             }
@@ -4059,10 +4062,8 @@ nsWindow::Create(nsIWidget* aParent,
       mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
     }
 #ifdef MOZ_WAYLAND
-    else {
-      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
-      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
-      mSurfaceProvider.Initialize(this, mWaylandDisplay, mWaylandSurface);
+    else if (!mIsX11Display) {
+      mSurfaceProvider.Initialize(this);
     }
 #endif
 #endif
@@ -4235,6 +4236,12 @@ nsWindow::NativeMoveResize()
     }
 }
 
+static void
+show_shell(GdkSeat *seat, GdkWindow *window, gpointer user_data)
+{
+    gtk_widget_show(GTK_WIDGET(user_data));
+}
+
 void
 nsWindow::NativeShow(bool aAction)
 {
@@ -4248,7 +4255,23 @@ nsWindow::NativeShow(bool aAction)
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
 
-            gtk_widget_show(mShell);
+            // TODO
+            if (0 && mWindowType == eWindowType_popup) {
+                mRetryPointerGrab = false;
+                //sRetryGrabTime = aTime;
+
+                GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+                gint retval = gdk_seat_grab(gdkSeat, gtk_widget_get_window(mShell),
+                                            GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                                            nullptr, nullptr, show_shell, mShell);
+                MOZ_ASSERT(retval == GDK_GRAB_SUCCESS);
+                if (retval == GDK_GRAB_NOT_VIEWABLE) {
+                    mRetryPointerGrab = true;
+                } else if (retval != GDK_GRAB_SUCCESS) {
+                }
+            } else {
+                gtk_widget_show(mShell);
+            }
         }
         else if (mContainer) {
             gtk_widget_show(GTK_WIDGET(mContainer));
@@ -7084,7 +7107,7 @@ void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInit
 #ifdef MOZ_WAYLAND
   if (!mIsX11Display) {
     *aInitData = mozilla::widget::CompositorWidgetInitData(
-                                  (uintptr_t)mWaylandSurface,
+                                  (uintptr_t)nullptr,
                                   nsCString(nullptr),
                                   GetClientSize());
   } else
@@ -7097,3 +7120,19 @@ void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInit
   }
 #endif
 }
+
+#ifdef MOZ_WAYLAND
+wl_display*
+nsWindow::GetWaylandDisplay()
+{
+  GdkDisplay* gdkDisplay = gdk_display_get_default();
+  return mIsX11Display ? nullptr :
+                         gdk_wayland_display_get_wl_display(gdkDisplay);
+}
+
+wl_surface*
+nsWindow::GetWaylandSurface()
+{
+  return moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+}
+#endif
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index 012e28fee114..8acf88bc6a53 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -354,7 +354,8 @@ public:
     Display* XDisplay() { return mXDisplay; }
 #endif
 #ifdef MOZ_WAYLAND
-    wl_display* WaylandDisplay() { return mWaylandDisplay; }
+    wl_display* GetWaylandDisplay();
+    wl_surface* GetWaylandSurface();
 #endif
     virtual void GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData) override;
 
@@ -469,10 +470,6 @@ private:
     Window              mXWindow;
     Visual*             mXVisual;
     int                 mXDepth;
-#ifdef MOZ_WAYLAND
-    wl_display*         mWaylandDisplay;
-    wl_surface*         mWaylandSurface;
-#endif
     mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 #endif
 
-- 
2.11.0


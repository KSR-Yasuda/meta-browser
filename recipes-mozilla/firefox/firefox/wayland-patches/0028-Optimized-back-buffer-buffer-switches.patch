From cec269ccefa8ed74c17d8fad507ef594d0e954e1 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Mon, 10 Apr 2017 21:15:28 +0200
Subject: [PATCH 28/44] Optimized back buffer buffer switches

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 widget/gtk/WindowSurfaceWayland.cpp | 198 +++++++++++++++++++++---------------
 widget/gtk/WindowSurfaceWayland.h   |  81 +++++++--------
 2 files changed, 159 insertions(+), 120 deletions(-)

diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
index fa52aaed2ce5..3d91a3f53f4b 100644
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -155,53 +155,8 @@ WaylandDisplay::WaylandDisplay(wl_display *aDisplay)
   mLoopThread = g_thread_new("WaylandDisplayLoop", WaylandDisplayLoop, this);
 }
 
-WaylandDisplay::~WaylandDisplay()
-{
-}
-
-ImageBuffer::ImageBuffer()
-  : mImageData(nullptr)
-  , mBufferAllocated(0)
-  , mWidth(0)
-  , mHeight(0)
-{
-}
-
-ImageBuffer::~ImageBuffer()
-{
-  if (mImageData)
-    free(mImageData);
-}
-
-already_AddRefed<gfx::DrawTarget>
-ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
-{
-  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
-  gfx::IntSize imageSize(bounds.XMost(), bounds.YMost());
-
-  //TODO -> widget->getBounds!!
-  int newSize = imageSize.width * imageSize.height * BUFFER_BPP;
-  if (!mImageData || mBufferAllocated < newSize) {
-    if (mImageData) {
-      free(mImageData);
-    }
-
-    mImageData = (unsigned char*)malloc(newSize);
-    if (!mImageData)
-      return nullptr;
-
-    mBufferAllocated = newSize;
-  }
-
-  mWidth = imageSize.width;
-  mHeight = imageSize.height;
-
-  return gfxPlatform::CreateDrawTargetForData(mImageData, imageSize,
-    BUFFER_BPP * mWidth, gWaylandDisplay->GetSurfaceFormat());
-}
-
 int
-WaylandShmBuffer::CreateTemporaryFile(int aSize)
+WaylandShmPool::CreateTemporaryFile(int aSize)
 {
   const char* tmppath = getenv("XDG_RUNTIME_DIR");
   MOZ_RELEASE_ASSERT(tmppath, "Missing XDG_RUNTIME_DIR env variable.");
@@ -238,7 +193,7 @@ WaylandShmBuffer::CreateTemporaryFile(int aSize)
   return fd;
 }
 
-WaylandShmBuffer::WaylandShmBuffer(int aSize)
+WaylandShmPool::WaylandShmPool(int aSize)
 {
   mAllocatedSize = aSize;
 
@@ -255,7 +210,7 @@ WaylandShmBuffer::WaylandShmBuffer(int aSize)
 }
 
 bool
-WaylandShmBuffer::Resize(int aSize)
+WaylandShmPool::Resize(int aSize)
 {
   // We do size increase only
   if (aSize <= mAllocatedSize)
@@ -283,13 +238,60 @@ WaylandShmBuffer::Resize(int aSize)
   return true;
 }
 
-WaylandShmBuffer::~WaylandShmBuffer()
+WaylandShmPool::~WaylandShmPool()
 {
   munmap(mImageData, mAllocatedSize);
   wl_shm_pool_destroy(mShmPool);
   close(mShmPoolFd);
 }
 
+WaylandDisplay::~WaylandDisplay()
+{
+}
+
+ImageBuffer::ImageBuffer()
+  : mImageData(nullptr)
+  , mBufferAllocated(0)
+  , mWidth(0)
+  , mHeight(0)
+{
+}
+
+ImageBuffer::~ImageBuffer()
+{
+  if (mImageData)
+    free(mImageData);
+}
+
+already_AddRefed<gfx::DrawTarget>
+ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize imageSize(bounds.XMost(), bounds.YMost());
+
+  // TODO - use widget bounds?
+  // LayoutDeviceIntRect rect = mWidget->GetBounds();
+
+  int newSize = imageSize.width * imageSize.height * BUFFER_BPP;
+  if (!mImageData || mBufferAllocated < newSize) {
+    if (mImageData) {
+      free(mImageData);
+    }
+
+    mImageData = (unsigned char*)malloc(newSize);
+    if (!mImageData)
+      return nullptr;
+
+    mBufferAllocated = newSize;
+  }
+
+  mWidth = imageSize.width;
+  mHeight = imageSize.height;
+
+  return gfxPlatform::CreateDrawTargetForData(mImageData, imageSize,
+    BUFFER_BPP * mWidth, gWaylandDisplay->GetSurfaceFormat());
+}
+
 static void
 buffer_release(void *data, wl_buffer *buffer)
 {
@@ -304,9 +306,9 @@ static const struct wl_buffer_listener buffer_listener = {
 void WindowBackBuffer::Create(int aWidth, int aHeight)
 {
   int newBufferSize = aWidth*aHeight*BUFFER_BPP;
-  mShmBuffer.Resize(newBufferSize);
+  mShmPool.Resize(newBufferSize);
 
-  mWaylandBuffer = wl_shm_pool_create_buffer(mShmBuffer.GetShmPool(), 0,
+  mWaylandBuffer = wl_shm_pool_create_buffer(mShmPool.GetShmPool(), 0,
                                             aWidth, aHeight, aWidth*BUFFER_BPP,
                                             WL_SHM_FORMAT_ARGB8888);
   wl_proxy_set_queue((struct wl_proxy *)mWaylandBuffer,
@@ -324,7 +326,7 @@ void WindowBackBuffer::Release()
 }
 
 WindowBackBuffer::WindowBackBuffer(int aWidth, int aHeight)
- : mShmBuffer(aWidth*aHeight*BUFFER_BPP)
+ : mShmPool(aWidth*aHeight*BUFFER_BPP)
   ,mWaylandBuffer(nullptr)
   ,mWidth(aWidth)
   ,mHeight(aHeight)
@@ -344,9 +346,6 @@ WindowBackBuffer::Resize(int aWidth, int aHeight)
   if (aWidth == mWidth && aHeight == mHeight)
     return true;
 
-  fprintf(stderr, "BackBufferResize, %dx%d -> %dx%d",
-          mWidth, mHeight, aWidth, aHeight);
-
   Release();
   Create(aWidth, aHeight);
 
@@ -368,7 +367,7 @@ WindowBackBuffer::CopyRectangle(ImageBuffer *aImage,
   for (int y = r.y; y < r.y + r.height; y++) {
     int start = (y * mWidth + r.x) * BUFFER_BPP;
     int lenght = r.width * BUFFER_BPP;
-    memcpy((unsigned char *)mShmBuffer.GetImageData() + start,
+    memcpy((unsigned char *)mShmPool.GetImageData() + start,
             aImage->GetImageData() + ((y * aImage->GetWidth()) + r.x) * BUFFER_BPP,
             lenght);
   }
@@ -403,7 +402,7 @@ bool WindowBackBuffer::Sync(class WindowBackBuffer* aSourceBuffer)
     Resize(aSourceBuffer->mWidth, aSourceBuffer->mHeight);
   }
 
-  memcpy(mShmBuffer.GetImageData(), aSourceBuffer->mShmBuffer.GetImageData(),
+  memcpy(mShmPool.GetImageData(), aSourceBuffer->mShmPool.GetImageData(),
          aSourceBuffer->mWidth * aSourceBuffer->mHeight * BUFFER_BPP);
   return true;
 }
@@ -428,6 +427,7 @@ WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
   , mBackBuffer(nullptr)
   , mFrameCallback(nullptr)
   , mDelayedCommit(false)
+  , mFullScreenDamage(false)
 {
   MOZ_RELEASE_ASSERT(mSurface != nullptr,
                     "We can't do anything useful without valid wl_surface.");
@@ -456,28 +456,38 @@ WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
   if (!mFrontBuffer) {
     mFrontBuffer = new WindowBackBuffer(aWidth, aHeight);
     mBackBuffer = new WindowBackBuffer(aWidth, aHeight);
-  } else {
-    if (mFrontBuffer->IsAttached()) {
-
-      if (mBackBuffer->IsAttached()) {
-        NS_ASSERTION(!mBackBuffer->IsAttached(), "We don't have any buffer to draw to!");
-        return nullptr;
-      }
-
-      WindowBackBuffer *tmp = mFrontBuffer;
-      mFrontBuffer = mBackBuffer;
-      mBackBuffer = tmp;
-
-      // TODO sync only when we don't resize after switch
-      mFrontBuffer->Sync(mBackBuffer);
-
-      // TODO (https://bugzilla.redhat.com/show_bug.cgi?id=1418260)
-      wl_surface_damage(mSurface, 0, 0, aWidth, aHeight);
-    }
+    return mFrontBuffer;
+  }
 
+  if (!mFrontBuffer->IsAttached()) {
     if (!mFrontBuffer->MatchSize(aWidth, aHeight)) {
       mFrontBuffer->Resize(aWidth, aHeight);
     }
+    return mFrontBuffer;
+  }
+
+  // Front buffer is used by compositor, draw to back buffer
+  if (mBackBuffer->IsAttached()) {
+      NS_ASSERTION(!mBackBuffer->IsAttached(), "We don't have any buffer to draw to!");
+      return nullptr;
+  }
+
+  WindowBackBuffer *tmp = mFrontBuffer;
+  mFrontBuffer = mBackBuffer;
+  mBackBuffer = tmp;
+
+  if (mBackBuffer->MatchSize(aWidth, aHeight)) {
+    // Former front buffer has the same size as a requested one.
+    // Gecko may expect a content already drawn on screen so copy
+    // existing data to the new buffer.
+    mFrontBuffer->Sync(mBackBuffer);
+    // When buffer switches we need to damage whole screen
+    // (https://bugzilla.redhat.com/show_bug.cgi?id=1418260)
+    mFullScreenDamage = true;
+  } else {
+    // Former buffer has different size from the new request. Only resize
+    // the new buffer and leave geck to render new whole content.
+    mFrontBuffer->Resize(aWidth, aHeight);
   }
 
   return mFrontBuffer;
@@ -486,18 +496,40 @@ WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
 already_AddRefed<gfx::DrawTarget>
 WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
 {
+  // We can use backbuffer directly when:
+  // 1) Front buffer is not used by compositor
+  // 2) We're asked for full screen area
+  // 3) No pre/after drawing - resize drop fullscreen, delete fullscreen flag between comits
+/*
+  if (!mFrontBuffer) {
+    LayoutDeviceIntRect rect = mWidget->GetBounds();
+    (void)GetBufferToDraw(rect.width, rect.height);
+  }
+
+  if (!mFrontBuffer->IsAttached()) {
+    LayoutDeviceIntRect rect = mWidget->GetBounds();
+    mFullScreen = false;
+    for (auto iter = aRegion.RectIter(); !iter.Done(); iter.Next()) {
+      const mozilla::LayoutDeviceIntRect &r = iter.Get();
+      if (r.x == 0 && r.y == 0 &&
+          r.width == rect.width && r.height == rect.height) {
+        fprintf(stderr, "************* Fulscreen %d x %d\n", r.width, r.height);
+        mFullScreen = true;
+        break;
+      }
+    }
+  }
+*/
   // TODO -> compare with bound size
   // and provide back buffer direcly when possible
   // (no data in img buffer and size match)
+  // and we also don't need to switch buffers
   return mImageBuffer.Lock(aRegion);
 }
 
 void
 WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
 {
-  gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
-  gfx::IntSize bufferSize(bounds.XMost(), bounds.YMost());
-
   LayoutDeviceIntRect rect = mWidget->GetBounds();
   WindowBackBuffer* buffer = GetBufferToDraw(rect.width,
                                              rect.height);
@@ -506,11 +538,17 @@ WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
     return;
   }
 
-  // TODO - overlapping areas?
+  // TODO - Do we want to fix redundat copy of overlapping areas?
   for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
     const mozilla::LayoutDeviceIntRect &r = iter.Get();
     buffer->CopyRectangle(&mImageBuffer, r);
-    wl_surface_damage(mSurface, r.x, r.y, r.width, r.height);
+    if (!mFullScreenDamage)
+      wl_surface_damage(mSurface, r.x, r.y, r.width, r.height);
+  }
+
+  if (mFullScreenDamage) {
+    wl_surface_damage(mSurface, 0, 0, rect.width, rect.height);
+    mFullScreenDamage = false;
   }
 
   if (mFrameCallback) {
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
index 707c796389ac..375bd7e86b69 100644
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -20,19 +20,38 @@ public:
   WaylandDisplay(wl_display *aDisplay);
   ~WaylandDisplay();
 
-  void               SetShm(wl_shm* aShm)   { mShm = aShm; };
-  wl_shm*            GetShm()               { return(mShm); };
-  wl_event_queue*    GetEventQueue()        { return mEventQueue; };
-  wl_display*        GetDisplay()           { return mDisplay; };
-  gfx::SurfaceFormat GetSurfaceFormat()     { return mFormat; };
-  void               SetWaylandPixelFormat(uint32_t format);
+  void                SetShm(wl_shm* aShm)   { mShm = aShm; };
+  wl_shm*             GetShm()               { return(mShm); };
+  wl_event_queue*     GetEventQueue()        { return mEventQueue; };
+  wl_display*         GetDisplay()           { return mDisplay; };
+  gfx::SurfaceFormat  GetSurfaceFormat()     { return mFormat; };
+  void                SetWaylandPixelFormat(uint32_t format);
 
 private:
-  gfx::SurfaceFormat mFormat;
-  wl_shm*            mShm;
-  wl_event_queue*    mEventQueue;
-  GThread*           mLoopThread;
-  wl_display*        mDisplay;
+  gfx::SurfaceFormat  mFormat;
+  wl_shm*             mShm;
+  wl_event_queue*     mEventQueue;
+  GThread*            mLoopThread;
+  wl_display*         mDisplay;
+};
+
+// Allocates and owns shared memory for Wayland drawing surfaces
+class WaylandShmPool {
+public:
+  WaylandShmPool(int aSize);
+  ~WaylandShmPool();
+
+  bool                Resize(int aSize);
+  wl_shm_pool*        GetShmPool()    { return mShmPool;   };
+  void*               GetImageData()  { return mImageData; };
+
+private:
+  int CreateTemporaryFile(int aSize);
+
+  wl_shm_pool*        mShmPool;
+  int                 mShmPoolFd;
+  int                 mAllocatedSize;
+  void*               mImageData;
 };
 
 class ImageBuffer {
@@ -46,29 +65,10 @@ public:
   int GetHeight()                { return mHeight; };
 
 private:
-  unsigned char*     mImageData;
-  int                mBufferAllocated;
-  int                mWidth;
-  int                mHeight;
-};
-
-// Allocates and owns shared memory for Wayland drawing surfaces
-class WaylandShmBuffer {
-public:
-  WaylandShmBuffer(int aSize);
-  ~WaylandShmBuffer();
-
-  bool          Resize(int aSize);
-  wl_shm_pool*  GetShmPool()    { return mShmPool;    };
-  void*         GetImageData()  { return mImageData; };
-
-private:
-  int CreateTemporaryFile(int aSize);
-
-  wl_shm_pool*       mShmPool;
-  int                mShmPoolFd;
-  int                mAllocatedSize;
-  void*              mImageData;
+  unsigned char*      mImageData;
+  int                 mBufferAllocated;
+  int                 mWidth;
+  int                 mHeight;
 };
 
 // Holds actual graphics data for wl_surface
@@ -100,15 +100,15 @@ private:
   void Create(int aWidth, int aHeight);
   void Release();
 
-  // WaylandShmBuffer provides actual shared memory we draw into
-  WaylandShmBuffer   mShmBuffer;
+  // WaylandShmPool provides actual shared memory we draw into
+  WaylandShmPool      mShmPool;
 
   // wl_buffer is a wayland object that encapsulates the shared memory
   // and passes it to wayland compositor by wl_surface object.
-  wl_buffer*         mWaylandBuffer;
-  int                mWidth;
-  int                mHeight;
-  bool               mAttached;
+  wl_buffer*          mWaylandBuffer;
+  int                 mWidth;
+  int                 mHeight;
+  bool                mAttached;
 };
 
 // WindowSurfaceWayland is an abstraction for wl_surface
@@ -140,6 +140,7 @@ private:
   WindowBackBuffer*         mBackBuffer;
   wl_callback*              mFrameCallback;
   bool                      mDelayedCommit;
+  bool                      mFullScreenDamage;
 };
 
 }  // namespace widget
-- 
2.11.0


From c8b3b907d0985dc0bb36ab7abfe8b6d779048857 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Wed, 26 Apr 2017 11:32:50 +0200
Subject: [PATCH] Fixed dbus params

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 toolkit/components/remote/nsGTKRemoteService.cpp |  35 ++--
 toolkit/components/remote/nsGTKRemoteService.h   |   3 +-
 toolkit/components/remote/nsXRemoteService.cpp   |  10 +-
 toolkit/components/remote/nsXRemoteService.h     |   2 +-
 widget/xremoteclient/XRemoteClient.cpp           | 223 ++++++++++++++++-------
 widget/xremoteclient/XRemoteClient.h             |  16 +-
 widget/xremoteclient/moz.build                   |   2 +
 7 files changed, 193 insertions(+), 98 deletions(-)

diff --git a/toolkit/components/remote/nsGTKRemoteService.cpp b/toolkit/components/remote/nsGTKRemoteService.cpp
index 29462c7228aa..52dae4060edd 100644
--- a/toolkit/components/remote/nsGTKRemoteService.cpp
+++ b/toolkit/components/remote/nsGTKRemoteService.cpp
@@ -172,11 +172,9 @@ nsGTKRemoteService::HandlePropertyChange(GtkWidget *aWidget,
 
 #ifdef ENABLE_REMOTE_DBUS
 
-void nsGTKRemoteService::OpenURL(const char *aCommandLine)
+void nsGTKRemoteService::OpenURL(const char *aCommandLine, int aLength)
 {
-  char* buffer = strdup(aCommandLine);
-  HandleCommandLine(buffer, nullptr, 0);
-  free(buffer);
+  HandleCommandLine(aCommandLine, nullptr, 0);
 }
 
 #define MOZILLA_REMOTE_OBJECT       "/org/mozilla/Firefox/Remote"
@@ -221,27 +219,28 @@ nsGTKRemoteService::OpenURL(DBusMessage *msg)
 {
   DBusMessage *reply = nullptr;
   const char  *commandLine;
+  int          length;
 
-  if (!dbus_message_get_args(msg, nullptr, DBUS_TYPE_STRING, &commandLine,
-                             DBUS_TYPE_INVALID)) {
+  if (!dbus_message_get_args(msg, nullptr, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+       &commandLine, &length, DBUS_TYPE_INVALID) || length == 0) {
     reply = dbus_message_new_error(msg, "org.mozilla.firefox.Error",
                                    "Wrong argument");
   } else {
-    OpenURL(commandLine);
+    OpenURL(commandLine, length);
     reply = dbus_message_new_method_return(msg);
   }
-  
+
   dbus_connection_send(mConnection, reply, NULL);
   dbus_message_unref(reply);
 
-  return DBUS_HANDLER_RESULT_HANDLED;  
+  return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 DBusHandlerResult
 nsGTKRemoteService::HandleDBusMessage(DBusConnection *aConnection, DBusMessage *msg)
 {
   NS_ASSERTION(mConnection == aConnection, "Wrong D-Bus connection.");
-  
+
   const char *method = dbus_message_get_member(msg);
   const char *iface = dbus_message_get_interface(msg);
 
@@ -250,7 +249,7 @@ nsGTKRemoteService::HandleDBusMessage(DBusConnection *aConnection, DBusMessage *
     return Introspect(msg);
   }
 
-  if ((strcmp("OpenURL", method) == 0) && 
+  if ((strcmp("OpenURL", method) == 0) &&
     (strcmp("org.mozilla.firefox", iface) == 0)) {
     return OpenURL(msg);
   }
@@ -287,6 +286,11 @@ static DBusObjectPathVTable remoteHandlersTable = {
 bool
 nsGTKRemoteService::Connect(const char* aAppName, const char* aProfileName)
 {
+  if (mConnection && dbus_connection_get_is_connected(mConnection)) {
+    // We're already connected so we don't need to reconnect
+    return true;
+  }
+
   mConnection = already_AddRefed<DBusConnection>(
     dbus_bus_get(DBUS_BUS_SESSION, nullptr));
   if (!mConnection)
@@ -316,15 +320,6 @@ nsGTKRemoteService::Connect(const char* aAppName, const char* aProfileName)
 
   return true;
 }
-
-void
-nsGTKRemoteService::Disconnect()
-{
-  if (mConnection) {
-    dbus_connection_unref(mConnection);
-    mConnection = nullptr;
-  }
-}
 #endif
 
 // {C0773E90-5799-4eff-AD03-3EBCD85624AC}
diff --git a/toolkit/components/remote/nsGTKRemoteService.h b/toolkit/components/remote/nsGTKRemoteService.h
index ae18de7a9cdc..ce6154b51dc2 100644
--- a/toolkit/components/remote/nsGTKRemoteService.h
+++ b/toolkit/components/remote/nsGTKRemoteService.h
@@ -58,13 +58,12 @@ private:
                                               uint32_t aTimestamp) override;
 
 #ifdef ENABLE_REMOTE_DBUS
-  void OpenURL(const char *aCommandLine);
+  void OpenURL(const char *aCommandLine, int aLength);
 
   DBusHandlerResult OpenURL(DBusMessage *msg);
   DBusHandlerResult Introspect(DBusMessage *msg);
 
   bool Connect(const char* aAppName, const char* aProfileName);
-  void Disconnect();
 #endif
 
   nsInterfaceHashtable<nsPtrHashKey<GtkWidget>, nsIWeakReference> mWindows;
diff --git a/toolkit/components/remote/nsXRemoteService.cpp b/toolkit/components/remote/nsXRemoteService.cpp
index 41a40e471939..10fa3afde6e5 100644
--- a/toolkit/components/remote/nsXRemoteService.cpp
+++ b/toolkit/components/remote/nsXRemoteService.cpp
@@ -237,7 +237,7 @@ nsXRemoteService::HandleNewProperty(XID aWindowId, Display* aDisplay,
 }
 
 const char*
-nsXRemoteService::HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
+nsXRemoteService::HandleCommandLine(const char* aBuffer, nsIDOMWindow* aWindow,
                                     uint32_t aTimestamp)
 {
   nsresult rv;
@@ -253,8 +253,8 @@ nsXRemoteService::HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
   // [argc][offsetargv0][offsetargv1...]<workingdir>\0<argv[0]>\0argv[1]...\0
   // (offset is from the beginning of the buffer)
 
-  int32_t argc = TO_LITTLE_ENDIAN32(*reinterpret_cast<int32_t*>(aBuffer));
-  char *wd   = aBuffer + ((argc + 1) * sizeof(int32_t));
+  int32_t argc = TO_LITTLE_ENDIAN32(*reinterpret_cast<const int32_t*>(aBuffer));
+  const char *wd   = aBuffer + ((argc + 1) * sizeof(int32_t));
 
   nsCOMPtr<nsIFile> lf;
   rv = NS_NewNativeLocalFile(nsDependentCString(wd), true,
@@ -264,10 +264,10 @@ nsXRemoteService::HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
 
   nsAutoCString desktopStartupID;
 
-  char **argv = (char**) malloc(sizeof(char*) * argc);
+  const char **argv = (const char**) malloc(sizeof(char*) * argc);
   if (!argv) return "509 internal error";
 
-  int32_t  *offset = reinterpret_cast<int32_t*>(aBuffer) + 1;
+  const int32_t  *offset = reinterpret_cast<const int32_t*>(aBuffer) + 1;
 
   for (int i = 0; i < argc; ++i) {
     argv[i] = aBuffer + TO_LITTLE_ENDIAN32(offset[i]);
diff --git a/toolkit/components/remote/nsXRemoteService.h b/toolkit/components/remote/nsXRemoteService.h
index 247949518504..0930f2a644f9 100644
--- a/toolkit/components/remote/nsXRemoteService.h
+++ b/toolkit/components/remote/nsXRemoteService.h
@@ -39,7 +39,7 @@ protected:
 
     void HandleCommandsFor(Window aWindowId);
     static nsXRemoteService *sRemoteImplementation;
-    static const char* HandleCommandLine(char* aBuffer, nsIDOMWindow* aWindow,
+    static const char* HandleCommandLine(const char* aBuffer, nsIDOMWindow* aWindow,
                                          uint32_t aTimestamp);
 
 private:
diff --git a/widget/xremoteclient/XRemoteClient.cpp b/widget/xremoteclient/XRemoteClient.cpp
index c4567f3cb9ab..51d3e088b84f 100644
--- a/widget/xremoteclient/XRemoteClient.cpp
+++ b/widget/xremoteclient/XRemoteClient.cpp
@@ -24,6 +24,10 @@
 #include <unistd.h>
 #include <limits.h>
 #include <X11/Xatom.h>
+#include "nsPrintfCString.h"
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
 
 #define MOZILLA_VERSION_PROP   "_MOZILLA_VERSION"
 #define MOZILLA_LOCK_PROP      "_MOZILLA_LOCK"
@@ -40,7 +44,7 @@
 #else
 #define TO_LITTLE_ENDIAN32(x) (x)
 #endif
-    
+
 #ifndef MAX_PATH
 #ifdef PATH_MAX
 #define MAX_PATH PATH_MAX
@@ -69,6 +73,8 @@ XRemoteClient::XRemoteClient()
   mMozProfileAtom = 0;
   mMozProgramAtom = 0;
   mLockData = 0;
+  mIsX11Display = true;
+  mConnection = nullptr;
   if (!sRemoteLm)
     sRemoteLm = PR_NewLogModule("XRemoteClient");
   MOZ_LOG(sRemoteLm, LogLevel::Debug, ("XRemoteClient::XRemoteClient"));
@@ -102,24 +108,38 @@ XRemoteClient::Init()
   if (mInitialized)
     return NS_OK;
 
-  // try to open the display
-  mDisplay = XOpenDisplay(0);
-  if (!mDisplay)
-    return NS_ERROR_FAILURE;
+  mIsX11Display = GDK_IS_X11_DISPLAY(gdk_display_get_default());
 
-  // get our atoms
-  XInternAtoms(mDisplay, const_cast<char**>(XAtomNames),
-               MOZ_ARRAY_LENGTH(XAtomNames), False, XAtoms);
+#ifdef ENABLE_REMOTE_DBUS
+  if (!mIsX11Display) {
+    mConnection = already_AddRefed<DBusConnection>(
+      dbus_bus_get(DBUS_BUS_SESSION, nullptr));
+    if (!mConnection)
+      return NS_ERROR_FAILURE;
 
-  int i = 0;
-  mMozVersionAtom  = XAtoms[i++];
-  mMozLockAtom     = XAtoms[i++];
-  mMozResponseAtom = XAtoms[i++];
-  mMozWMStateAtom  = XAtoms[i++];
-  mMozUserAtom     = XAtoms[i++];
-  mMozProfileAtom  = XAtoms[i++];
-  mMozProgramAtom  = XAtoms[i++];
-  mMozCommandLineAtom = XAtoms[i++];
+    dbus_connection_set_exit_on_disconnect(mConnection, false);
+  } else
+#endif
+  {
+    // try to open the display
+    mDisplay = XOpenDisplay(0);
+    if (!mDisplay)
+      return NS_ERROR_FAILURE;
+
+    // get our atoms
+    XInternAtoms(mDisplay, const_cast<char**>(XAtomNames),
+                 MOZ_ARRAY_LENGTH(XAtomNames), False, XAtoms);
+
+    int i = 0;
+    mMozVersionAtom  = XAtoms[i++];
+    mMozLockAtom     = XAtoms[i++];
+    mMozResponseAtom = XAtoms[i++];
+    mMozWMStateAtom  = XAtoms[i++];
+    mMozUserAtom     = XAtoms[i++];
+    mMozProfileAtom  = XAtoms[i++];
+    mMozProgramAtom  = XAtoms[i++];
+    mMozCommandLineAtom = XAtoms[i++];
+  }
 
   mInitialized = true;
 
@@ -134,8 +154,20 @@ XRemoteClient::Shutdown (void)
   if (!mInitialized)
     return;
 
-  // shut everything down
-  XCloseDisplay(mDisplay);
+// shut everything down
+#ifdef ENABLE_REMOTE_DBUS
+  if (!mIsX11Display) {
+    if (mConnection) {
+      // This connection is owned by libdbus and we don't need to close it
+      mConnection = nullptr;
+    }
+  } else
+#endif
+  {
+    if (mDisplay)
+      XCloseDisplay(mDisplay);
+  }
+
   mDisplay = 0;
   mInitialized = false;
   if (mLockData) {
@@ -151,9 +183,9 @@ HandleBadWindow(Display *display, XErrorEvent *event)
     sGotBadWindow = true;
     return 0; // ignored
   }
-  else {
+
     return (*sOldHandler)(display, event);
-  }
+
 }
 
 nsresult
@@ -165,48 +197,55 @@ XRemoteClient::SendCommandLine (const char *aProgram, const char *aUsername,
 {
   MOZ_LOG(sRemoteLm, LogLevel::Debug, ("XRemoteClient::SendCommandLine"));
 
-  *aWindowFound = false;
-
-  // FindBestWindow() iterates down the window hierarchy, so catch X errors
-  // when windows get destroyed before being accessed.
-  sOldHandler = XSetErrorHandler(HandleBadWindow);
-
-  Window w = FindBestWindow(aProgram, aUsername, aProfile);
-
   nsresult rv = NS_OK;
 
-  if (w) {
-    // ok, let the caller know that we at least found a window.
-    *aWindowFound = true;
+#ifdef ENABLE_REMOTE_DBUS
+  if (!mIsX11Display) {
+    rv = DoSendCommandLine(0, argc, argv, aDesktopStartupID, aResponse,
+                           nullptr, aProgram, aProfile);
+    *aWindowFound = NS_SUCCEEDED(rv);
+  } else
+#endif
+  {
+    *aWindowFound = false;
+
+    // FindBestWindow() iterates down the window hierarchy, so catch X errors
+    // when windows get destroyed before being accessed.
+    sOldHandler = XSetErrorHandler(HandleBadWindow);
 
-    // Ignore BadWindow errors up to this point.  The last request from
-    // FindBestWindow() was a synchronous XGetWindowProperty(), so no need to
-    // Sync.  Leave the error handler installed to detect if w gets destroyed.
-    sGotBadWindow = false;
+    Window w = FindBestWindow(aProgram, aUsername, aProfile);
+    if (w) {
+      // ok, let the caller know that we at least found a window.
+      *aWindowFound = true;
 
-    // make sure we get the right events on that window
-    XSelectInput(mDisplay, w,
-                 (PropertyChangeMask|StructureNotifyMask));
+      // Ignore BadWindow errors up to this point.  The last request from
+      // FindBestWindow() was a synchronous XGetWindowProperty(), so no need to
+      // Sync.  Leave the error handler installed to detect if w gets destroyed.
+      sGotBadWindow = false;
 
-    bool destroyed = false;
+      // make sure we get the right events on that window
+      XSelectInput(mDisplay, w,
+                   (PropertyChangeMask|StructureNotifyMask));
 
-    // get the lock on the window
-    rv = GetLock(w, &destroyed);
+      bool destroyed = false;
 
-    if (NS_SUCCEEDED(rv)) {
-      // send our command
-      rv = DoSendCommandLine(w, argc, argv, aDesktopStartupID, aResponse,
-                             &destroyed);
+      // get the lock on the window
+      rv = GetLock(w, &destroyed);
 
-      // if the window was destroyed, don't bother trying to free the
-      // lock.
-      if (!destroyed)
-          FreeLock(w); // doesn't really matter what this returns
+      if (NS_SUCCEEDED(rv)) {
+        // send our command
+        rv = DoSendCommandLine(w, argc, argv, aDesktopStartupID, aResponse,
+                               &destroyed, aProgram, aProfile);
 
+        // if the window was destroyed, don't bother trying to free the
+        // lock.
+        if (!destroyed)
+            FreeLock(w); // doesn't really matter what this returns
+      }
     }
-  }
 
-  XSetErrorHandler(sOldHandler);
+    XSetErrorHandler(sOldHandler);
+  }
 
   MOZ_LOG(sRemoteLm, LogLevel::Debug, ("SendCommandInternal returning 0x%x\n", rv));
 
@@ -252,11 +291,11 @@ XRemoteClient::CheckChildren(Window aWindow)
   unsigned long nitems, after;
   unsigned char *data;
   Window retval = None;
-  
+
   if (!XQueryTree(mDisplay, aWindow, &root, &parent, &children,
 		  &nchildren))
     return None;
-  
+
   // scan the list first before recursing into the list of windows
   // which can get quite deep.
   for (i=0; !retval && (i < nchildren); i++) {
@@ -290,7 +329,7 @@ XRemoteClient::GetLock(Window aWindow, bool *aDestroyed)
   nsresult rv = NS_OK;
 
   if (!mLockData) {
-    
+
     char pidstr[32];
     char sysinfobuf[SYS_INFO_BUFFER_LENGTH];
     SprintfLiteral(pidstr, "pid%d@", getpid());
@@ -300,7 +339,7 @@ XRemoteClient::GetLock(Window aWindow, bool *aDestroyed)
     if (status != PR_SUCCESS) {
       return NS_ERROR_FAILURE;
     }
-    
+
     // allocate enough space for the string plus the terminating
     // char
     mLockData = (char *)malloc(strlen(pidstr) + strlen(sysinfobuf) + 1);
@@ -353,7 +392,7 @@ XRemoteClient::GetLock(Window aWindow, bool *aDestroyed)
       /* We tried to grab the lock this time, and failed because someone
 	 else is holding it already.  So, wait for a PropertyDelete event
 	 to come in, and try again. */
-      MOZ_LOG(sRemoteLm, LogLevel::Debug, 
+      MOZ_LOG(sRemoteLm, LogLevel::Debug,
 	     ("window 0x%x is locked by %s; waiting...\n",
 	      (unsigned int) aWindow, data));
       waited = True;
@@ -477,7 +516,7 @@ XRemoteClient::FindBestWindow(const char *aProgram, const char *aUsername,
                                     False, XA_STRING,
                                     &type, &format, &nitems, &bytesafter,
                                     &data_return);
-        
+
         // If the return name is not the same as what someone passed in,
         // we don't want this window.
         if (data_return) {
@@ -617,9 +656,11 @@ estrcpy(const char* s, char* d)
 nsresult
 XRemoteClient::DoSendCommandLine(Window aWindow, int32_t argc, char **argv,
                                  const char* aDesktopStartupID,
-                                 char **aResponse, bool *aDestroyed)
+                                 char **aResponse, bool *aDestroyed,
+                                 const char *aProgram, const char *aProfile)
 {
-  *aDestroyed = false;
+  if (aDestroyed)
+    *aDestroyed = false;
 
   char cwdbuf[MAX_PATH];
   if (!getcwd(cwdbuf, MAX_PATH))
@@ -677,15 +718,21 @@ XRemoteClient::DoSendCommandLine(Window aWindow, int32_t argc, char **argv,
     printf("  argv[%i]:\t%s\n", debug_i,
            ((char*) buffer) + TO_LITTLE_ENDIAN32(debug_offset[debug_i]));
 #endif
+#ifdef ENABLE_REMOTE_DBUS
+  if (!mIsX11Display) {
+    return DoSendDBusCommandLine(aProgram, aProfile, (unsigned char *)buffer,
+                                 bufend - ((char*)buffer));
+  } else
+#endif
+  {
+    XChangeProperty (mDisplay, aWindow, mMozCommandLineAtom, XA_STRING, 8,
+                     PropModeReplace, (unsigned char *) buffer,
+                     bufend - ((char*)buffer));
+    free(buffer);
 
-  XChangeProperty (mDisplay, aWindow, mMozCommandLineAtom, XA_STRING, 8,
-                   PropModeReplace, (unsigned char *) buffer,
-                   bufend - ((char*) buffer));
-  free(buffer);
-
-  if (!WaitForResponse(aWindow, aResponse, aDestroyed, mMozCommandLineAtom))
-    return NS_ERROR_FAILURE;
-  
+    if (!WaitForResponse(aWindow, aResponse, aDestroyed, mMozCommandLineAtom))
+      return NS_ERROR_FAILURE;
+  }
   return NS_OK;
 }
 
@@ -798,8 +845,46 @@ XRemoteClient::WaitForResponse(Window aWindow, char **aResponse,
               MOZILLA_COMMANDLINE_PROP ".)\n",
               (unsigned int) aWindow));
     }
-    
+
   }
 
   return accepted;
 }
+
+nsresult
+XRemoteClient::DoSendDBusCommandLine(const char *aProgram, const char *aProfile,
+                                     unsigned char* aBuffer, int aLength)
+{
+  nsAutoCString interfaceName;
+  interfaceName = nsPrintfCString("org.mozilla.%s.%s", aProgram, aProfile);
+
+  DBusMessage* msg;
+  msg = dbus_message_new_method_call(interfaceName.get(), // target for the method call
+                                     "/org/mozilla/Firefox/Remote", // object to call on
+                                     "org.mozilla.firefox", // interface to call on
+                                     "OpenURL"); // method name
+  if (!msg) {
+    return NS_ERROR_FAILURE;
+  }
+
+  // append arguments
+  if (!dbus_message_append_args(msg, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE,
+                                &aBuffer, aLength, DBUS_TYPE_INVALID)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  // send message and get a handle for a reply
+  DBusError err;
+  dbus_error_init(&err);
+  DBusMessage* reply = dbus_connection_send_with_reply_and_block(mConnection,
+                                                                 msg, -1, &err);
+  dbus_message_unref(msg);
+
+  if (!reply) {
+    dbus_error_free(&err);
+    return NS_ERROR_FAILURE;
+	} else {
+    dbus_message_unref(reply);
+    return NS_OK;
+  }
+}
diff --git a/widget/xremoteclient/XRemoteClient.h b/widget/xremoteclient/XRemoteClient.h
index 840716ad9bb0..d3fc5f9ce594 100644
--- a/widget/xremoteclient/XRemoteClient.h
+++ b/widget/xremoteclient/XRemoteClient.h
@@ -7,6 +7,10 @@
 #include <X11/Xlib.h>
 
 #include "nsRemoteClient.h"
+#if defined(MOZ_WAYLAND) && defined(MOZ_ENABLE_DBUS)
+#define  ENABLE_REMOTE_DBUS 1
+#include "mozilla/ipc/DBusConnectionRefPtr.h"
+#endif
 
 class XRemoteClient : public nsRemoteClient
 {
@@ -35,9 +39,15 @@ private:
                                    int32_t argc, char **argv,
                                    const char* aDesktopStartupID,
                                    char **aResponse,
-                                   bool *aDestroyed);
+                                   bool *aDestroyed,
+                                   const char *aProgram,
+                                   const char *aProfile);
   bool           WaitForResponse  (Window aWindow, char **aResponse,
                                    bool *aDestroyed, Atom aCommandAtom);
+#ifdef ENABLE_REMOTE_DBUS
+  nsresult       DoSendDBusCommandLine(const char *aProgram, const char *aProfile,
+                                       unsigned char* aBuffer, int aLength);
+#endif
 
   Display       *mDisplay;
 
@@ -53,4 +63,8 @@ private:
   char          *mLockData;
 
   bool           mInitialized;
+#ifdef ENABLE_REMOTE_DBUS
+  bool           mIsX11Display;
+  RefPtr<DBusConnection> mConnection;
+#endif
 };
diff --git a/widget/xremoteclient/moz.build b/widget/xremoteclient/moz.build
index 8d3f01c827c9..28350772d5e4 100644
--- a/widget/xremoteclient/moz.build
+++ b/widget/xremoteclient/moz.build
@@ -9,3 +9,5 @@ FINAL_LIBRARY = 'xul'
 SOURCES += [
     'XRemoteClient.cpp',
 ]
+
+CXXFLAGS += CONFIG['TK_CFLAGS']
-- 
2.11.0


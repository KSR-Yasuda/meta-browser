From a0f958ed6bedd846d7ff7ac018ee5af28e8a7a98 Mon Sep 17 00:00:00 2001
From: Martin Stransky <stransky@redhat.com>
Date: Fri, 17 Mar 2017 18:17:18 +0900
Subject: [PATCH 01/44] Added wayland patch

Signed-off-by: Hiroshi Hatake <hatake@clear-code.com>
---
 config/system-headers                |   1 +
 dom/ipc/ContentChild.cpp             |  39 +++-
 gfx/gl/GLContextProviderGLX.cpp      |   7 +-
 gfx/thebes/gfxFcPlatformFontList.cpp |  16 +-
 gfx/thebes/gfxPlatformGtk.cpp        |  37 ++-
 gfx/thebes/gfxPlatformGtk.h          |  26 ++-
 toolkit/library/moz.build            |   3 +
 widget/gtk/WindowSurfaceProvider.cpp |  60 +++--
 widget/gtk/WindowSurfaceProvider.h   |  23 +-
 widget/gtk/WindowSurfaceWayland.cpp  | 425 +++++++++++++++++++++++++++++++++++
 widget/gtk/WindowSurfaceWayland.h    |  86 +++++++
 widget/gtk/X11CompositorWidget.cpp   |  47 ++--
 widget/gtk/X11CompositorWidget.h     |   5 +
 widget/gtk/moz.build                 |   2 +
 widget/gtk/mozcontainer.c            | 198 +++++++++++++++-
 widget/gtk/mozcontainer.h            |  23 +-
 widget/gtk/mozgtk/mozgtk.c           |  10 +-
 widget/gtk/nsNativeThemeGTK.cpp      |  30 +--
 widget/gtk/nsScreenGtk.cpp           |  10 +-
 widget/gtk/nsWindow.cpp              |  86 +++++--
 widget/gtk/nsWindow.h                |   8 +
 widget/gtk/os-compatibility.c        | 201 +++++++++++++++++
 widget/gtk/os-compatibility.h        |  54 +++++
 widget/nsIWidget.h                   |   2 +
 24 files changed, 1296 insertions(+), 103 deletions(-)
 create mode 100644 widget/gtk/WindowSurfaceWayland.cpp
 create mode 100644 widget/gtk/WindowSurfaceWayland.h
 create mode 100644 widget/gtk/os-compatibility.c
 create mode 100644 widget/gtk/os-compatibility.h

diff --git a/config/system-headers b/config/system-headers
index be3162f58edb..74a52ab0a16b 100644
--- a/config/system-headers
+++ b/config/system-headers
@@ -489,6 +489,7 @@ gdk/gdkkeysyms.h
 gdk/gdkprivate.h
 gdk/gdkx.h
 gdk/gdkdirectfb.h
+gdk/gdkwayland.h
 gdk-pixbuf/gdk-pixbuf.h
 Gestalt.h
 getopt.h
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index 8a265503b050..7a554cf506a8 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -524,6 +524,43 @@ NS_INTERFACE_MAP_BEGIN(ContentChild)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentChild)
 NS_INTERFACE_MAP_END
 
+#ifdef MOZ_WIDGET_GTK
+static char* detectDisplay(void)
+{
+  bool tryX11 = false;
+  bool tryWayland = false;
+  bool tryBroadway = false;
+
+  // Honor user backend selection
+  const char *backend = PR_GetEnv("GDK_BACKEND");
+  if (!backend || strstr(backend, "*")) {
+    // Try all backends
+    tryX11 = true;
+    tryWayland = true;
+    tryBroadway = true;
+  } else if (backend) {
+    if (strstr(backend, "x11"))
+      tryX11 = true;
+    if (strstr(backend, "wayland"))
+      tryWayland = true;
+    if (strstr(backend, "broadway"))
+      tryBroadway = true;
+  }
+
+  char *display_name;
+  if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
+    return display_name;
+  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+    return display_name;
+  } else if (tryBroadway && (display_name = PR_GetEnv("BROADWAY_DISPLAY"))) {
+    return display_name;
+  }
+
+  printf_stderr("Error: GDK_BACKEND does not match available displays\n");
+  return nullptr;
+}
+#endif // MOZ_WIDGET_GTK
+
 bool
 ContentChild::Init(MessageLoop* aIOLoop,
                    base::ProcessId aParentPid,
@@ -535,7 +572,7 @@ ContentChild::Init(MessageLoop* aIOLoop,
   // to use, and when starting under XWayland, it may choose to start with
   // the wayland backend instead of the x11 backend.
   // The DISPLAY environment variable is normally set by the parent process.
-  char* display_name = PR_GetEnv("DISPLAY");
+  char* display_name = detectDisplay();
   if (display_name) {
     int argc = 3;
     char option_name[] = "--display";
diff --git a/gfx/gl/GLContextProviderGLX.cpp b/gfx/gl/GLContextProviderGLX.cpp
index 9a1157f330cb..44cb61fe386a 100644
--- a/gfx/gl/GLContextProviderGLX.cpp
+++ b/gfx/gl/GLContextProviderGLX.cpp
@@ -67,6 +67,12 @@ HasExtension(const char* aExtensions, const char* aRequiredExtension)
 bool
 GLXLibrary::EnsureInitialized()
 {
+#ifdef MOZ_WIDGET_GTK
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+        return false;
+    }
+#endif
+
     if (mInitialized) {
         return true;
     }
@@ -1418,4 +1424,3 @@ GLContextProviderGLX::Shutdown()
 
 } /* namespace gl */
 } /* namespace mozilla */
-
diff --git a/gfx/thebes/gfxFcPlatformFontList.cpp b/gfx/thebes/gfxFcPlatformFontList.cpp
index 4b82e80f5f9f..d598bfaad308 100644
--- a/gfx/thebes/gfxFcPlatformFontList.cpp
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp
@@ -772,13 +772,15 @@ PreparePattern(FcPattern* aPattern, bool aIsPrinterFont)
 #endif
 
 #ifdef MOZ_X11
-        FcValue value;
-        int lcdfilter;
-        if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
-                == FcResultNoMatch &&
-            GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
-            FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
-        }
+       if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+           FcValue value;
+           int lcdfilter;
+           if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
+               == FcResultNoMatch &&
+               GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
+               FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+           }
+       }
 #endif
     }
 
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index 9d7f512f27a7..20fbd3df7d21 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -55,6 +55,10 @@
 
 #endif /* MOZ_X11 */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <fontconfig/fontconfig.h>
 
 #include "nsMathUtils.h"
@@ -105,14 +109,20 @@ gfxPlatformGtk::gfxPlatformGtk()
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
 
-#ifdef MOZ_X11
-    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
-      mCompositorDisplay = XOpenDisplay(nullptr);
-      MOZ_ASSERT(mCompositorDisplay, "Failed to create compositor display!");
-    } else {
-      mCompositorDisplay = nullptr;
+#if defined(MOZ_X11)
+    GdkDisplay *gdkDisplay = gdk_display_get_default();
+    mIsX11Display = GDK_IS_X11_DISPLAY(gdkDisplay);
+    if (mIsX11Display) {
+      mXCompositorDisplay = XOpenDisplay(nullptr);
+      MOZ_ASSERT(mXCompositorDisplay, "Failed to create compositor display!");
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+      mWaylandCompositorDisplay = wl_display_connect(nullptr);
+      MOZ_ASSERT(mWaylandCompositorDisplay, "Failed to create compositor display!");
     }
-#endif // MOZ_X11
+#endif
+#endif // defined(MOZ_X11)
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
@@ -123,11 +133,16 @@ gfxPlatformGtk::~gfxPlatformGtk()
         gfxPangoFontGroup::Shutdown();
     }
 
-#ifdef MOZ_X11
-    if (mCompositorDisplay) {
-      XCloseDisplay(mCompositorDisplay);
+#if defined(MOZ_X11)
+    if (mIsX11Display) {
+       XCloseDisplay(mXCompositorDisplay);
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+       wl_display_disconnect(mWaylandCompositorDisplay);
     }
-#endif // MOZ_X11
+#endif
+#endif
 }
 
 void
diff --git a/gfx/thebes/gfxPlatformGtk.h b/gfx/thebes/gfxPlatformGtk.h
index 982390d1867b..9110352f1fbb 100644
--- a/gfx/thebes/gfxPlatformGtk.h
+++ b/gfx/thebes/gfxPlatformGtk.h
@@ -21,6 +21,12 @@ extern "C" {
 struct _XDisplay;
 typedef struct _XDisplay Display;
 #endif // MOZ_X11
+#ifndef GDK_WINDOWING_WAYLAND
+#define GDK_WINDOWING_WAYLAND 1
+#endif
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_display;
+#endif
 
 class gfxFontconfigUtils;
 
@@ -104,7 +110,7 @@ public:
     static int32_t GetDPI();
     static double  GetDPIScale();
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     virtual void GetAzureBackendInfo(mozilla::widget::InfoObject &aObj) override {
       gfxPlatform::GetAzureBackendInfo(aObj);
       aObj.DefineProperty("CairoUseXRender", mozilla::gfx::gfxVars::UseXRender());
@@ -146,9 +152,17 @@ public:
 #endif
 
 #ifdef MOZ_X11
-    Display* GetCompositorDisplay() {
-      return mCompositorDisplay;
+    bool     IsXDisplay() {
+      return mIsX11Display;
+    }
+    Display* GetXCompositorDisplay() {
+      return mXCompositorDisplay;
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* GetWaylandCompositorDisplay() {
+      return mWaylandCompositorDisplay;
+    }
+#endif
 #endif // MOZ_X11
 
 protected:
@@ -161,7 +175,11 @@ private:
                                              size_t &size) override;
 
 #ifdef MOZ_X11
-    Display* mCompositorDisplay;
+    bool        mIsX11Display;
+    Display*    mXCompositorDisplay;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* mWaylandCompositorDisplay;
+#endif
 #endif
 
     // xxx - this will be removed once the new fontconfig platform font list
diff --git a/toolkit/library/moz.build b/toolkit/library/moz.build
index a9bdf123dd32..a7724c4130d6 100644
--- a/toolkit/library/moz.build
+++ b/toolkit/library/moz.build
@@ -313,6 +313,9 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     OS_LIBS += [
         'gthread-2.0',
     ]
+    OS_LIBS += [
+        'wayland-client',
+    ]
 
 if CONFIG['MOZ_ENABLE_STARTUP_NOTIFICATION']:
     OS_LIBS += CONFIG['MOZ_STARTUP_NOTIFICATION_LIBS']
diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index 526fe6a2596f..d51726c00015 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -11,6 +11,7 @@
 #include "WindowSurfaceX11Image.h"
 #include "WindowSurfaceX11SHM.h"
 #include "WindowSurfaceXRender.h"
+#include "WindowSurfaceWayland.h"
 
 namespace mozilla {
 namespace widget {
@@ -19,11 +20,14 @@ using namespace mozilla::gfx;
 using namespace mozilla::layers;
 
 WindowSurfaceProvider::WindowSurfaceProvider()
-    : mXDisplay(nullptr)
+    : mIsX11Display(false)
+    , mXDisplay(nullptr)
     , mXWindow(0)
     , mXVisual(nullptr)
     , mXDepth(0)
     , mWindowSurface(nullptr)
+    , mWaylandDisplay(nullptr)
+    , mWaylandSurface(nullptr)
 {
 }
 
@@ -43,7 +47,21 @@ void WindowSurfaceProvider::Initialize(
   mXWindow = aWindow;
   mXVisual = aVisual;
   mXDepth = aDepth;
+  mIsX11Display = true;
 }
+#ifdef GDK_WINDOWING_WAYLAND
+void WindowSurfaceProvider::Initialize(
+      wl_display *aWaylandDisplay,
+      wl_surface *aWaylandSurface)
+{
+  // We should not be initialized
+  MOZ_ASSERT(!mWaylandSurface);
+
+  mWaylandDisplay = aWaylandDisplay;
+  mWaylandSurface = aWaylandSurface;
+  mIsX11Display = false;
+}
+#endif
 void WindowSurfaceProvider::CleanupResources()
 {
   mWindowSurface = nullptr;
@@ -52,30 +70,36 @@ void WindowSurfaceProvider::CleanupResources()
 UniquePtr<WindowSurface>
 WindowSurfaceProvider::CreateWindowSurface()
 {
-  // We should be initialized
-  MOZ_ASSERT(mXDisplay);
+  if (mIsX11Display) {
+    // We should be initialized
+    MOZ_ASSERT(mXDisplay);
 
-  // Blit to the window with the following priority:
-  // 1. XRender (iff XRender is enabled && we are in-process)
-  // 2. MIT-SHM
-  // 3. XPutImage
+    // Blit to the window with the following priority:
+    // 1. XRender (iff XRender is enabled && we are in-process)
+    // 2. MIT-SHM
+    // 3. XPutImage
 
 #ifdef MOZ_WIDGET_GTK
-  if (gfxVars::UseXRender()) {
-    LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
-    return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (gfxVars::UseXRender()) {
+      LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
+      return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_WIDGET_GTK
 
 #ifdef MOZ_HAVE_SHMIMAGE
-  if (nsShmImage::UseShm()) {
-    LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
-    return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (nsShmImage::UseShm()) {
+      LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
+      return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_HAVE_SHMIMAGE
 
-  LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
-  return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
+    return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  } else {
+    MOZ_ASSERT(mWaylandDisplay);
+    LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
+    return MakeUnique<WindowSurfaceWayland>(mWaylandDisplay, mWaylandSurface);
+  }
 }
 
 already_AddRefed<gfx::DrawTarget>
@@ -93,7 +117,7 @@ WindowSurfaceProvider::StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvali
 
   *aBufferMode = BufferMode::BUFFER_NONE;
   RefPtr<DrawTarget> dt = nullptr;
-  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) &&
+  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) && mIsX11Display &&
       !mWindowSurface->IsFallback()) {
     gfxWarningOnce() << "Failed to lock WindowSurface, falling back to XPutImage backend.";
     mWindowSurface = MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index 73b23031e5f8..2e268ba83551 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -11,6 +11,10 @@
 #include "mozilla/gfx/Types.h"
 #include "mozilla/gfx/2D.h"
 #include "Units.h"
+#include <gdk/gdk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 
 #include <X11/Xlib.h> // for Window, Display, Visual, etc.
 
@@ -38,6 +42,10 @@ public:
       Window aWindow,
       Visual* aVisual,
       int aDepth);
+#ifdef GDK_WINDOWING_WAYLAND
+   void Initialize(wl_display *aWaylandDisplay,
+                   wl_surface *aWaylandSurface);
+#endif
 
   /**
    * Releases any surfaces created by this provider.
@@ -55,12 +63,17 @@ public:
 private:
   UniquePtr<WindowSurface> CreateWindowSurface();
 
-  Display*  mXDisplay;
-  Window    mXWindow;
-  Visual*   mXVisual;
-  int       mXDepth;
-
+  // Can we access X?
+  bool        mIsX11Display;
+  Display*    mXDisplay;
+  Window      mXWindow;
+  Visual*     mXVisual;
+  int         mXDepth;
   UniquePtr<WindowSurface> mWindowSurface;
+#ifdef GDK_WINDOWING_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif
 };
 
 }  // namespace widget
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
new file mode 100644
index 000000000000..1622abe92a86
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -0,0 +1,425 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * Derived from Weston project,
+ * https://github.com/wayland-project/weston/blob/master/clients/simple-shm.c
+ */
+/*
+- make it work single thread, no e10s
+- simple multi-thread app
+- abort() on exhausted buffer pool
+
+TODO:
+moz-container -> display check
+X11CompositorWidget - update
+nsWindow::GetCompositorWidgetInitData
+GDK_WINDOWING_X11 - remove
+#ifdef GDK_WINDOWING_WAYLAND + display test
+- ensure we always draw to container
+- surface cleaning/realocation
+- can we redraw on allocate?
+- create subsurface on show
+- share fd/pool with more buffers?
+- resize (pool size) optimization
+- pool of available buffers?
+- call wayland display/queue events right after attach&co?
+*/
+#include <assert.h>
+#include <poll.h>
+
+#include "WindowSurfaceWayland.h"
+
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/Tools.h"
+#include "gfxPlatform.h"
+#include "os-compatibility.h"
+
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+#include <sys/mman.h>
+#include <fcntl.h>
+
+namespace mozilla {
+namespace widget {
+
+bool                WindowSurfaceWayland::mIsAvailable;
+bool                WindowSurfaceWayland::mInitialized;
+gfx::SurfaceFormat  WindowSurfaceWayland::mFormat = gfx::SurfaceFormat::UNKNOWN;
+wl_shm*             WindowSurfaceWayland::mShm;
+wl_event_queue*     WindowSurfaceWayland::mQueue;
+GThread*            WindowSurfaceWayland::mThread;
+wl_display*         WindowSurfaceWayland::mDisplay;
+
+bool SurfaceBuffer::CreateShmPool(int aSize)
+{
+  mAllocatedSize = aSize;
+
+  mShmPoolFd = os_create_anonymous_file(mAllocatedSize);
+  if (mShmPoolFd < 0)
+    return false;
+
+  mBufferData = mmap(nullptr, mAllocatedSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED) {
+    close(mShmPoolFd);
+    mShmPoolFd = 0;
+    return false;
+  }
+
+  mShmPool = wl_shm_create_pool(WindowSurfaceWayland::GetShm(),
+                                mShmPoolFd, mAllocatedSize);
+  wl_proxy_set_queue((struct wl_proxy *)mShmPool,
+                     WindowSurfaceWayland::GetQueue());
+                                
+  return true;
+}
+
+bool SurfaceBuffer::ResizeShmPool(int aSize)
+{
+  // We do size increase only
+  if (aSize <= mAllocatedSize)
+    return true;
+
+  if (ftruncate(mShmPoolFd, aSize) < 0)
+    return false;
+
+#ifdef HAVE_POSIX_FALLOCATE
+  errno = posix_fallocate(mShmPoolFd, 0, aSize);
+  if (errno != 0)
+    return false;
+#endif
+
+  wl_shm_pool_resize(mShmPool, aSize);
+
+  munmap(mBufferData, mAllocatedSize);
+
+  mBufferData = mmap(nullptr, aSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED)
+    return false;
+
+  mAllocatedSize = aSize;
+  return true;
+}
+
+void SurfaceBuffer::ReleaseShmPool()
+{
+  munmap(mBufferData, mAllocatedSize);
+  wl_shm_pool_destroy(mShmPool);
+  close(mShmPoolFd);
+
+  mBufferData = nullptr;
+  mAllocatedSize = 0;
+}
+
+static void
+buffer_release(void *data, wl_buffer *buffer)
+{  
+  auto surface = reinterpret_cast<SurfaceBuffer*>(data);
+  surface->Detach();
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+  buffer_release
+};
+
+void SurfaceBuffer::CreateBuffer(int aWidth, int aHeight)
+{
+  mBuffer = wl_shm_pool_create_buffer(mShmPool, 0,
+                              			  aWidth, aHeight, aWidth*BUFFER_BPP,
+                              			  WL_SHM_FORMAT_ARGB8888);
+  wl_proxy_set_queue((struct wl_proxy *)mBuffer,
+                     WindowSurfaceWayland::GetQueue());
+  wl_buffer_add_listener(mBuffer, &buffer_listener, this);
+
+  mWidth = aWidth;
+  mHeight = aHeight;
+}
+
+void SurfaceBuffer::ReleaseBuffer()
+{
+  wl_buffer_destroy(mBuffer);
+  mWidth = mHeight = 0;
+}
+
+SurfaceBuffer::SurfaceBuffer(int aWidth, int aHeight)
+ : mShmPool(nullptr)
+  ,mShmPoolFd(0)
+  ,mAllocatedSize(0)
+  ,mBuffer(nullptr)
+  ,mBufferData(nullptr)
+  ,mWidth(0)
+  ,mHeight(0)
+  ,mFormat(gfx::SurfaceFormat::B8G8R8A8)
+  ,mAttached(false)
+{
+  if(CreateShmPool(aWidth*aHeight*BUFFER_BPP)) {
+    CreateBuffer(aWidth, aHeight);
+  } else
+    assert(0);
+}
+
+SurfaceBuffer::~SurfaceBuffer()
+{
+  ReleaseBuffer();
+  ReleaseShmPool();
+}
+
+bool SurfaceBuffer::Resize(int aWidth, int aHeight)
+{
+  if (aWidth == mWidth && aHeight == mHeight)
+    return true;
+
+  ReleaseBuffer();
+
+  int newSize = aWidth*aHeight*BUFFER_BPP;
+  if (newSize > mAllocatedSize)
+    ResizeShmPool(newSize);
+
+  CreateBuffer(aWidth, aHeight);
+  return (mBuffer != nullptr);
+}
+
+already_AddRefed<gfx::DrawTarget>
+SurfaceBuffer::Lock()
+{
+  unsigned char* data = static_cast<unsigned char*>(mBufferData);
+  return gfxPlatform::CreateDrawTargetForData(data,
+                                              gfx::IntSize(mWidth, mHeight),
+                                              mWidth*BUFFER_BPP,
+                                              mFormat);
+}
+
+void
+SurfaceBuffer::Attach(wl_surface* aSurface,
+                      const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+
+  fprintf(stderr, "Commit %d,%d -> %d x %d\n", bounds.x, bounds.y, size.width, size.height);
+  wl_surface_damage(aSurface, bounds.x, bounds.y, size.width, size.height);
+  wl_surface_attach(aSurface, mBuffer, 0, 0);
+  wl_surface_commit(aSurface);
+
+  // Taken from Hybris project:
+  // Some compositors, namely Weston, queue buffer release events instead
+  // of sending them immediately.  If a frame event is used, this should
+  // not be a problem.  Without a frame event, we need to send a sync
+  // request to ensure that they get flushed.    
+  //wl_callback_destroy(wl_display_sync(WindowSurfaceWayland::GetDisplay()));
+  
+  wl_display_flush(WindowSurfaceWayland::GetDisplay());
+
+  mAttached = true;
+}
+
+void
+SurfaceBuffer::Detach()
+{
+  mAttached = false;
+}
+
+bool SurfaceBuffer::Sync(class SurfaceBuffer* aSourceBuffer)
+{
+  if (mWidth != aSourceBuffer->mWidth || mHeight != aSourceBuffer->mHeight)
+    return false;
+
+  int bufferSize = mWidth*mHeight*BUFFER_BPP;
+  memcpy(mBufferData, aSourceBuffer->mBufferData, bufferSize);
+  return true;
+}
+
+void
+WindowSurfaceWayland::SetWaylandPixelFormat(uint32_t format)
+{
+  switch (format) {
+    case WL_SHM_FORMAT_ARGB8888:
+      mFormat = gfx::SurfaceFormat::B8G8R8A8;
+      break;
+    case WL_SHM_FORMAT_XRGB8888:
+      // TODO - We can use non-alpha formats when we need that
+    default:
+      break;
+  }
+}
+
+static void
+shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+{
+  auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+  interface->SetWaylandPixelFormat(format);
+ }
+
+struct wl_shm_listener shm_listener = {
+	shm_format
+};
+
+static void
+global_registry_handler(void *data, wl_registry *registry, uint32_t id,
+	                      const char *interface, uint32_t version)
+{
+  if (strcmp(interface, "wl_shm") == 0) {
+    auto shm = static_cast<wl_shm*>(
+        wl_registry_bind(registry, id, &wl_shm_interface, 1));
+    wl_proxy_set_queue((struct wl_proxy *)shm, WindowSurfaceWayland::GetQueue());
+    wl_shm_add_listener(shm, &shm_listener, NULL);
+    auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+    interface->SetShm(shm);
+  }
+}
+
+static void
+global_registry_remover(void *data, wl_registry *registry, uint32_t id)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  global_registry_handler,
+  global_registry_remover
+};
+
+static gpointer
+gst_wl_display_thread_run (gpointer data)
+{
+  struct pollfd fds;
+  fds.fd = wl_display_get_fd (WindowSurfaceWayland::GetDisplay());
+  fds.events = POLLIN;
+
+  /* main loop */
+  while (1) {
+    fprintf(stderr, "***** Loop Enter 1.\n");
+    while (wl_display_prepare_read_queue (WindowSurfaceWayland::GetDisplay(),
+                                          WindowSurfaceWayland::GetQueue()) < 0) {
+      wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
+                                         WindowSurfaceWayland::GetQueue());
+    }
+    wl_display_flush (WindowSurfaceWayland::GetDisplay());
+
+    fprintf(stderr, "***** Loop Enter 2.\n");
+    int ret = poll(&fds, 1, -1);
+    fprintf(stderr, "***** Loop Enter 3.\n");
+    if (ret == -1) {
+      wl_display_cancel_read(WindowSurfaceWayland::GetDisplay());
+      fprintf(stderr, "***** Loop error!!\n");
+      break;
+    }
+    wl_display_read_events(WindowSurfaceWayland::GetDisplay());
+    wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(), 
+                                       WindowSurfaceWayland::GetQueue());
+  }
+
+  return NULL;
+}
+
+extern "C" {
+struct wl_event_queue* moz_container_get_wl_queue();
+}
+
+void
+WindowSurfaceWayland::Init()
+{
+  // Try to initialize only once
+  if (mInitialized)
+    return;
+  mInitialized = true;
+  
+  mQueue = moz_container_get_wl_queue();
+
+  // wl_shm and wl_subcompositor are not provided by Gtk so we need
+  // to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);
+  wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
+  wl_registry_add_listener(registry,
+                           &registry_listener, nullptr);
+  wl_display_dispatch_queue(mDisplay, mQueue);
+  wl_display_roundtrip_queue(mDisplay, mQueue);
+
+  // We should have a valid pixel format now
+  mIsAvailable = (mFormat != gfx::SurfaceFormat::UNKNOWN);
+  NS_ASSERTION(mIsAvailable, "We don't have any pixel format!");
+
+  GError *err = nullptr;
+  mThread = g_thread_try_new ("GstWlDisplay", gst_wl_display_thread_run,
+                              this, &err);
+}
+
+WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
+                                           wl_surface *aSurface)
+  : mSurface(aSurface)
+  , mBuffers{nullptr, nullptr}
+  , mFrontBuffer(0)
+  , mLastBuffer(0)
+{
+  NS_ASSERTION(mSurface != nullptr,
+               "Missing Wayland surfaces to draw to!");
+
+  mDisplay = aDisplay;
+  Init();
+  wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);
+}
+
+WindowSurfaceWayland::~WindowSurfaceWayland()
+{
+  // TODO - free registry, buffers etc.
+}
+
+SurfaceBuffer*
+WindowSurfaceWayland::SetBufferToDraw(int aWidth, int aHeight)
+{
+  int i;
+  for (i = 0; i < 100; i++) {
+    if (!mBuffers[i] || !mBuffers[i]->IsAttached()) {
+      mFrontBuffer = i;
+      break;
+    }
+  }
+    
+  assert(i != 100);
+  
+  if (mBuffers[mFrontBuffer] != nullptr) {
+    mBuffers[mFrontBuffer]->Resize(aWidth, aHeight);
+  } else {
+    mBuffers[mFrontBuffer] = new SurfaceBuffer(aWidth, aHeight);    
+  }
+
+  fprintf(stderr, "WindowSurfaceWayland %p Take Buffer[%d] %d x %d\n", this, mFrontBuffer, aWidth, aHeight);
+
+  /*
+  // Sync last and front buffer
+  if (mFrontBuffer != mLastBuffer) {  
+    mBuffers[mFrontBuffer]->Sync(mBuffers[mLastBuffer]);
+    mLastBuffer = mFrontBuffer;
+  }
+  */
+
+  return mBuffers[mFrontBuffer]->IsValid() ? mBuffers[mFrontBuffer] : nullptr;
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+
+  SurfaceBuffer* buffer = SetBufferToDraw(size.width, size.height);
+  if (!buffer)
+    return nullptr;
+
+  return buffer->Lock();
+}
+
+void
+WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  MOZ_ASSERT(mBuffers[mFrontBuffer], "Attempted to commit invalid surface!");  
+  mBuffers[mFrontBuffer]->Attach(mSurface, aInvalidRegion);
+}
+
+}  // namespace widget
+}  // namespace mozilla
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
new file mode 100644
index 000000000000..8a320400280d
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -0,0 +1,86 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+#define _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+
+namespace mozilla {
+namespace widget {
+
+// We support only 32bpp formats
+#define BUFFER_BPP 4
+
+// Holds actual graphics data for wl_surface
+class SurfaceBuffer {
+public:
+  SurfaceBuffer(int aWidth, int aHeight);
+  ~SurfaceBuffer();
+
+  void Attach(wl_surface* aSurface,
+              const LayoutDeviceIntRegion& aInvalidRegion);
+  void Detach();
+  bool IsAttached() { return mAttached; }
+  bool IsValid()    { return mBuffer && mBufferData; }
+
+  bool Resize(int aWidth, int aHeight);
+  bool Sync(class SurfaceBuffer* aSourceBuffer);
+  
+  already_AddRefed<gfx::DrawTarget> Lock();
+
+private:
+  bool CreateShmPool(int aSize);
+  bool ResizeShmPool(int aSize);
+  void ReleaseShmPool(void);
+
+  void CreateBuffer(int aWidth, int aHeight);
+  void ReleaseBuffer();
+
+  wl_shm_pool*       mShmPool;
+  int                mShmPoolFd;
+  int                mAllocatedSize;
+  wl_buffer*         mBuffer;
+  void*              mBufferData;
+  int                mWidth;
+  int                mHeight;
+  gfx::SurfaceFormat mFormat;
+  bool               mAttached;
+};
+
+class WindowSurfaceWayland : public WindowSurface {
+public:
+  WindowSurfaceWayland(wl_display *aDisplay, wl_surface *aSurface);
+  ~WindowSurfaceWayland();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
+  void                      Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
+
+  static void               SetShm(wl_shm* aShm) { mShm = aShm; };
+  static wl_shm*            GetShm() { return(mShm); };
+  static wl_event_queue*    GetQueue() { return mQueue; };
+  static wl_display*        GetDisplay() { return mDisplay; };
+  static void               SetWaylandPixelFormat(uint32_t format);
+
+private:
+  SurfaceBuffer*            SetBufferToDraw(int aWidth, int aHeight);
+  void                      Init();
+
+  static bool               mIsAvailable;
+  static bool               mInitialized;
+  static gfx::SurfaceFormat mFormat;
+  static wl_shm*            mShm;
+  static wl_event_queue*    mQueue;
+  static GThread*           mThread;
+  static wl_display*        mDisplay;
+  wl_surface*               mSurface;
+  SurfaceBuffer*            mBuffers[100];
+  int                       mFrontBuffer;
+  int                       mLastBuffer;
+};
+
+}  // namespace widget
+}  // namespace mozilla
+
+#endif // _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
diff --git a/widget/gtk/X11CompositorWidget.cpp b/widget/gtk/X11CompositorWidget.cpp
index 05113a0c3a6c..ba484c934aea 100644
--- a/widget/gtk/X11CompositorWidget.cpp
+++ b/widget/gtk/X11CompositorWidget.cpp
@@ -21,26 +21,39 @@ X11CompositorWidget::X11CompositorWidget(const CompositorWidgetInitData& aInitDa
   // If we have a nsWindow, then grab the already existing display connection
   // If we don't, then use the init data to connect to the display
   if (aWindow) {
-    mXDisplay = aWindow->XDisplay();
+    mIsX11Display = aWindow->IsX11Display();
+    if (mIsX11Display) {
+      mXDisplay = aWindow->XDisplay();
+    } else {
+      mWaylandDisplay = aWindow->WaylandDisplay();
+    }
   } else {
+    // TODO - not implemented
+    abort();
     mXDisplay = XOpenDisplay(aInitData.XDisplayString().get());
   }
-  mXWindow = (Window)aInitData.XWindow();
-
-  // Grab the window's visual and depth
-  XWindowAttributes windowAttrs;
-  XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
-
-  Visual*   visual = windowAttrs.visual;
-  int       depth = windowAttrs.depth;
-
-  // Initialize the window surface provider
-  mProvider.Initialize(
-    mXDisplay,
-    mXWindow,
-    visual,
-    depth
-    );
+
+  if (mIsX11Display) {
+    mXWindow = (Window)aInitData.XWindow();
+
+    // Grab the window's visual and depth
+    XWindowAttributes windowAttrs;
+    XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
+
+    Visual*   visual = windowAttrs.visual;
+    int       depth = windowAttrs.depth;
+
+    // Initialize the window surface provider
+    mProvider.Initialize(
+      mXDisplay,
+      mXWindow,
+      visual,
+      depth
+      );
+  } else {
+    mWaylandSurface = (wl_surface *)aInitData.XWindow();
+    mProvider.Initialize(mWaylandDisplay, mWaylandSurface);
+  }
 
   mClientSize = aInitData.InitialClientSize();
 }
diff --git a/widget/gtk/X11CompositorWidget.h b/widget/gtk/X11CompositorWidget.h
index c0e0edeb3351..7221d19c2bf0 100644
--- a/widget/gtk/X11CompositorWidget.h
+++ b/widget/gtk/X11CompositorWidget.h
@@ -58,8 +58,13 @@ protected:
 private:
   LayoutDeviceIntSize mClientSize;
 
+  bool     mIsX11Display;
   Display* mXDisplay;
   Window   mXWindow;
+#ifdef GDK_WINDOWING_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif
   WindowSurfaceProvider mProvider;
 };
 
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index baccb6ccd900..714e6a030b3a 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -34,6 +34,7 @@ UNIFIED_SOURCES += [
     'nsSound.cpp',
     'nsToolkit.cpp',
     'nsWidgetFactory.cpp',
+    'os-compatibility.c',
     'WakeLockListener.cpp',
     'WidgetTraceEvent.cpp',
     'WidgetUtilsGtk.cpp',
@@ -74,6 +75,7 @@ if CONFIG['MOZ_X11']:
         'nsClipboard.cpp',
         'nsDragService.cpp',
         'WindowSurfaceProvider.cpp',
+        'WindowSurfaceWayland.cpp',
         'WindowSurfaceX11.cpp',
         'WindowSurfaceX11Image.cpp',
         'WindowSurfaceXRender.cpp',
diff --git a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.c
index 9b596e4fb84c..fffc5c485181 100644
--- a/widget/gtk/mozcontainer.c
+++ b/widget/gtk/mozcontainer.c
@@ -7,12 +7,16 @@
 
 #include "mozcontainer.h"
 #include <gtk/gtk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <stdio.h>
 
 #ifdef ACCESSIBILITY
 #include <atk/atk.h>
 #include "maiRedundantObjectFactory.h"
-#endif 
+#endif
 
 /* init methods */
 static void moz_container_class_init          (MozContainerClass *klass);
@@ -22,6 +26,9 @@ static void moz_container_init                (MozContainer      *container);
 static void moz_container_map                 (GtkWidget         *widget);
 static void moz_container_unmap               (GtkWidget         *widget);
 static void moz_container_realize             (GtkWidget         *widget);
+#if defined(GDK_WINDOWING_WAYLAND)
+static void moz_container_unrealize           (GtkWidget         *widget);
+#endif
 static void moz_container_size_allocate       (GtkWidget         *widget,
                                                GtkAllocation     *allocation);
 
@@ -35,6 +42,8 @@ static void moz_container_forall      (GtkContainer      *container,
 static void moz_container_add         (GtkContainer      *container,
                                         GtkWidget        *widget);
 
+static struct wl_event_queue *mQueue;
+
 typedef struct _MozContainerChild MozContainerChild;
 
 struct _MozContainerChild {
@@ -143,6 +152,82 @@ moz_container_move (MozContainer *container, GtkWidget *child_widget,
 
 /* static methods */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+/* We have to recreate our wl_surfaces when GdkWindow is shown,
+ * otherwise Gdk resources may not finished
+ * and gdk_wayland_window_get_wl_surface() fails.
+ */
+gboolean
+moz_container_map_wl_surface(MozContainer *container)
+{
+    GdkDisplay *display;
+    struct wl_compositor *compositor;
+    struct wl_surface *gtk_surface;
+    struct wl_region *region;
+    GdkWindow *window;
+    gint x, y;
+
+    if (container->subsurface)
+      return TRUE;
+
+    window = gtk_widget_get_window(GTK_WIDGET(container));
+    gtk_surface = gdk_wayland_window_get_wl_surface(window);
+    if (!gtk_surface) {
+      // We requested the underlying wl_surface too early.
+      return FALSE;
+    }
+    //wl_proxy_set_queue((struct wl_proxy *)gtk_surface, mQueue);
+
+    container->subsurface =
+      wl_subcompositor_get_subsurface (container->subcompositor,
+                                       container->surface,
+                                       gtk_surface);
+    wl_proxy_set_queue((struct wl_proxy *)container->subsurface, mQueue);
+    gdk_window_get_position(window, &x, &y);
+    wl_subsurface_set_position(container->subsurface, x, y);
+    wl_subsurface_set_desync(container->subsurface);
+
+    // Don't accept input on subsurface
+    display = gtk_widget_get_display(GTK_WIDGET (container));
+    compositor = gdk_wayland_display_get_wl_compositor(display);
+    region = wl_compositor_create_region(compositor);
+    wl_surface_set_input_region(container->surface, region);
+    wl_region_destroy(region);
+    return TRUE;
+}
+
+static void
+moz_container_unmap_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
+}
+
+static void
+moz_container_create_surface(MozContainer *container)
+{
+    if (!mQueue) {
+      GdkDisplay *display = gtk_widget_get_display(GTK_WIDGET(container));
+      mQueue = wl_display_create_queue(gdk_wayland_display_get_wl_display(display));
+    }
+
+    if (container->subcompositor && !container->surface) {
+        GdkDisplay *display;
+        struct wl_compositor *compositor;
+
+        display = gtk_widget_get_display(GTK_WIDGET (container));
+        compositor = gdk_wayland_display_get_wl_compositor(display);
+        container->surface = wl_compositor_create_surface(compositor);
+        wl_proxy_set_queue((struct wl_proxy *)container->surface, mQueue);
+    }
+}
+
+static void
+moz_container_delete_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->surface, wl_surface_destroy);
+}
+#endif
+
 void
 moz_container_class_init (MozContainerClass *klass)
 {
@@ -154,6 +239,9 @@ moz_container_class_init (MozContainerClass *klass)
     widget_class->map = moz_container_map;
     widget_class->unmap = moz_container_unmap;
     widget_class->realize = moz_container_realize;
+#if defined(GDK_WINDOWING_WAYLAND)
+    widget_class->unrealize = moz_container_unrealize;
+#endif
     widget_class->size_allocate = moz_container_size_allocate;
 
     container_class->remove = moz_container_remove;
@@ -161,12 +249,61 @@ moz_container_class_init (MozContainerClass *klass)
     container_class->add = moz_container_add;
 }
 
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+registry_handle_global (void *data,
+                        struct wl_registry *registry,
+                        uint32_t name,
+                        const char *interface,
+                        uint32_t version)
+{
+    MozContainer *container = data;
+    if(strcmp(interface, "wl_subcompositor") == 0) {
+        container->subcompositor = wl_registry_bind(registry,
+                                                    name,
+                                                    &wl_subcompositor_interface,
+                                                    1);
+    }
+}
+
+static void
+registry_handle_global_remove (void *data,
+                               struct wl_registry *registry,
+                               uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+#endif
+
 void
 moz_container_init (MozContainer *container)
 {
     gtk_widget_set_can_focus(GTK_WIDGET(container), TRUE);
     gtk_container_set_resize_mode(GTK_CONTAINER(container), GTK_RESIZE_IMMEDIATE);
     gtk_widget_set_redraw_on_allocate(GTK_WIDGET(container), FALSE);
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    {
+      GdkDisplay *gdk_display = gtk_widget_get_display(GTK_WIDGET(container));
+      if (GDK_IS_WAYLAND_DISPLAY (gdk_display)) {
+          struct wl_display *display;
+          struct wl_registry *registry;
+
+          display = gdk_wayland_display_get_wl_display(gdk_display);
+          if (!mQueue) {
+            mQueue = wl_display_create_queue(display);
+          }
+          registry = wl_display_get_registry(display);
+          wl_registry_add_listener(registry, &registry_listener, container);
+          wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
+          wl_display_roundtrip_queue(display, mQueue);
+        }
+    }
+#endif
 }
 
 void
@@ -184,7 +321,7 @@ moz_container_map (GtkWidget *widget)
     tmp_list = container->children;
     while (tmp_list) {
         tmp_child = ((MozContainerChild *)tmp_list->data)->widget;
-    
+
         if (gtk_widget_get_visible(tmp_child)) {
             if (!gtk_widget_get_mapped(tmp_child))
                 gtk_widget_map(tmp_child);
@@ -207,6 +344,13 @@ moz_container_unmap (GtkWidget *widget)
     if (gtk_widget_get_has_window (widget)) {
         gdk_window_hide (gtk_widget_get_window(widget));
     }
+#if defined(GDK_WINDOWING_WAYLAND)
+  /* Gdk/Wayland deletes underlying GdkWindow wl_surface on unmap event.
+   * Delete the wl_subsurface interface which
+   * keeps wl_surface object and it's available to reuse.
+   */
+    moz_container_unmap_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
 void
@@ -221,6 +365,7 @@ moz_container_realize (GtkWidget *widget)
         GdkWindowAttr attributes;
         gint attributes_mask = GDK_WA_VISUAL | GDK_WA_X | GDK_WA_Y;
         GtkAllocation allocation;
+        GtkWidget* parent_widget;
 
         gtk_widget_get_allocation (widget, &allocation);
         attributes.event_mask = gtk_widget_get_events (widget);
@@ -231,6 +376,16 @@ moz_container_realize (GtkWidget *widget)
         attributes.wclass = GDK_INPUT_OUTPUT;
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.window_type = GDK_WINDOW_CHILD;
+#if defined(GDK_WINDOWING_WAYLAND)
+        /* TODO: We may optimize the code to use GDK_WINDOW_SUBSURFACE
+         * for all windows
+         */
+        parent_widget = gtk_widget_get_parent(widget);
+        if (parent_widget &&
+            gtk_window_get_window_type(GTK_WINDOW(parent_widget)) == GTK_WINDOW_POPUP) {
+            attributes.window_type = GDK_WINDOW_SUBSURFACE;
+        }
+#endif
 
 #if (MOZ_WIDGET_GTK == 2)
         attributes.colormap = gtk_widget_get_colormap (widget);
@@ -255,8 +410,21 @@ moz_container_realize (GtkWidget *widget)
 #if (MOZ_WIDGET_GTK == 2)
     widget->style = gtk_style_attach (widget->style, widget->window);
 #endif
+#if defined(GDK_WINDOWING_WAYLAND)
+    moz_container_create_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+moz_container_unrealize (GtkWidget *widget)
+{
+  MozContainer* container = MOZ_CONTAINER(widget);
+  moz_container_unmap_surface(container);
+  moz_container_delete_surface(container);
+}
+#endif
+
 void
 moz_container_size_allocate (GtkWidget     *widget,
                              GtkAllocation *allocation)
@@ -306,6 +474,14 @@ moz_container_size_allocate (GtkWidget     *widget,
                                allocation->width,
                                allocation->height);
     }
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    if (container->subsurface) {
+        gint x, y;
+        gdk_window_get_position(gtk_widget_get_window(widget), &x, &y);
+        wl_subsurface_set_position(container->subsurface, x, y);
+      }
+#endif
 }
 
 void
@@ -363,7 +539,7 @@ moz_container_forall (GtkContainer *container, gboolean include_internals,
 {
     MozContainer *moz_container;
     GList *tmp_list;
-  
+
     g_return_if_fail (IS_MOZ_CONTAINER(container));
     g_return_if_fail (callback != NULL);
 
@@ -399,7 +575,7 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     tmp_list = container->children;
     while (tmp_list) {
         MozContainerChild *child;
-    
+
         child = tmp_list->data;
         tmp_list = tmp_list->next;
 
@@ -410,9 +586,21 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     return NULL;
 }
 
-static void 
+static void
 moz_container_add(GtkContainer *container, GtkWidget *widget)
 {
     moz_container_put(MOZ_CONTAINER(container), widget, 0, 0);
 }
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface*
+moz_container_get_wl_surface(MozContainer *container)
+{
+    return container->surface;
+}
+struct wl_event_queue*
+moz_container_get_wl_queue()
+{
+    return mQueue;
+}
+#endif
diff --git a/widget/gtk/mozcontainer.h b/widget/gtk/mozcontainer.h
index 23e17f7b39c8..c4018d459b3e 100644
--- a/widget/gtk/mozcontainer.h
+++ b/widget/gtk/mozcontainer.h
@@ -44,7 +44,7 @@ extern "C" {
  * gtk_widget_set_parent_window should be called on the child GtkWidget before
  * it is realized.
  */
- 
+
 #define MOZ_CONTAINER_TYPE            (moz_container_get_type())
 #define MOZ_CONTAINER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MOZ_CONTAINER_TYPE, MozContainer))
 #define MOZ_CONTAINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), MOZ_CONTAINER_TYPE, MozContainerClass))
@@ -55,10 +55,25 @@ extern "C" {
 typedef struct _MozContainer      MozContainer;
 typedef struct _MozContainerClass MozContainerClass;
 
+/* Workaround for bug at wayland-util.h,
+ * present in wayland < 1.12
+ */
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_subcompositor;
+struct wl_surface;
+struct wl_subsurface;
+#endif
+
 struct _MozContainer
 {
     GtkContainer   container;
     GList         *children;
+
+#ifdef GDK_WINDOWING_WAYLAND
+    struct wl_subcompositor *subcompositor;
+    struct wl_surface       *surface;
+    struct wl_subsurface    *subsurface;
+#endif
 };
 
 struct _MozContainerClass
@@ -79,6 +94,12 @@ void       moz_container_move          (MozContainer *container,
                                         gint          width,
                                         gint          height);
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface * moz_container_get_wl_surface (MozContainer *container);
+gboolean            moz_container_map_wl_surface (MozContainer *container);
+struct wl_event_queue* moz_container_get_wl_queue();
+#endif
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
index d9fb9385d959..c9d554a21355 100644
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -515,11 +515,19 @@ STUB(gdk_device_manager_get_client_pointer)
 STUB(gdk_disable_multidevice)
 STUB(gdk_device_manager_list_devices)
 STUB(gdk_display_get_device_manager)
+STUB(gdk_display_get_default_seat)
 STUB(gdk_error_trap_pop_ignored)
 STUB(gdk_event_get_source_device)
+STUB(gdk_seat_grab)
+STUB(gdk_seat_ungrab)
 STUB(gdk_window_get_type)
 STUB(gdk_x11_window_get_xid)
 STUB(gdk_x11_display_get_type)
+STUB(gdk_wayland_window_get_wl_surface)
+STUB(gdk_wayland_window_set_use_custom_surface)
+STUB(gdk_wayland_display_get_wl_display)
+STUB(gdk_wayland_display_get_wl_compositor)
+STUB(gdk_wayland_display_get_type)
 STUB(gtk_box_new)
 STUB(gtk_cairo_should_draw_window)
 STUB(gtk_cairo_transform_to_window)
@@ -586,6 +594,7 @@ STUB(gtk_widget_path_iter_add_class)
 STUB(gtk_widget_path_new)
 STUB(gtk_widget_path_unref)
 STUB(gtk_widget_set_visual)
+STUB(gtk_widget_unregister_window)
 STUB(gtk_app_chooser_dialog_new_for_content_type)
 STUB(gtk_app_chooser_get_type)
 STUB(gtk_app_chooser_get_app_info)
@@ -631,4 +640,3 @@ XShmQueryExtension(Display* aDisplay)
   return False;
 }
 #endif
-
diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
index 89b8ab7dc8da..fa835b52b1cc 100644
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -101,7 +101,7 @@ nsNativeThemeGTK::RefreshWidgetWindow(nsIFrame* aFrame)
   nsViewManager* vm = shell->GetViewManager();
   if (!vm)
     return;
- 
+
   vm->InvalidateAllViews();
 }
 
@@ -663,7 +663,7 @@ nsNativeThemeGTK::GetGtkWidgetAndState(uint8_t aWidgetType, nsIFrame* aFrame,
   case NS_THEME_SPLITTER:
     if (IsHorizontal(aFrame))
       aGtkWidgetType = MOZ_GTK_SPLITTER_VERTICAL;
-    else 
+    else
       aGtkWidgetType = MOZ_GTK_SPLITTER_HORIZONTAL;
     break;
   case NS_THEME_MENUBAR:
@@ -728,7 +728,7 @@ private:
 };
 
 nsresult
-ThemeRenderer::DrawWithGDK(GdkDrawable * drawable, gint offsetX, 
+ThemeRenderer::DrawWithGDK(GdkDrawable * drawable, gint offsetX,
         gint offsetY, GdkRectangle * clipRects, uint32_t numClipRects)
 {
   GdkRectangle gdk_rect = mGDKRect;
@@ -744,7 +744,7 @@ ThemeRenderer::DrawWithGDK(GdkDrawable * drawable, gint offsetX,
   surfaceRect.y = 0;
   gdk_drawable_get_size(drawable, &surfaceRect.width, &surfaceRect.height);
   gdk_rectangle_intersect(&gdk_clip, &surfaceRect, &gdk_clip);
-  
+
   NS_ASSERTION(numClipRects == 0, "We don't support clipping!!!");
   moz_gtk_widget_paint(mGTKWidgetType, drawable, &gdk_rect, &gdk_clip,
                        &mState, mFlags, mDirection);
@@ -1204,7 +1204,7 @@ nsNativeThemeGTK::DrawWidgetBackground(nsRenderingContext* aContext,
   GdkColormap* colormap = moz_gtk_widget_get_colormap();
 
   renderer.Draw(ctx, drawingRect.Size(), rendererFlags, colormap);
-#else 
+#else
   DrawThemeWithCairo(ctx, aContext->GetDrawTarget(),
                      state, gtkWidgetType, flags, direction, scaleFactor,
                      snapped, ToPoint(origin), drawingRect.Size(),
@@ -1212,7 +1212,11 @@ nsNativeThemeGTK::DrawWidgetBackground(nsRenderingContext* aContext,
 #endif
 
   if (!safeState) {
-    gdk_flush();
+    // gdk_flush() call from expose event crashes Gtk+ on Wayland
+    // (Gnome BZ #773307)
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      gdk_flush();
+    }
     gLastGdkError = gdk_error_trap_pop ();
 
     if (gLastGdkError) {
@@ -1600,7 +1604,7 @@ nsNativeThemeGTK::GetMinimumWidgetSize(nsPresContext* aPresContext,
 
       moz_gtk_get_menu_separator_height(&separator_height);
       aResult->height = separator_height;
-    
+
       *aIsOverridable = false;
     }
     break;
@@ -1667,9 +1671,9 @@ nsNativeThemeGTK::GetMinimumWidgetSize(nsPresContext* aPresContext,
   case NS_THEME_SEPARATOR:
     {
       gint separator_width;
-    
+
       moz_gtk_get_toolbar_separator_width(&separator_width);
-    
+
       aResult->width = separator_width;
     }
     break;
@@ -1708,7 +1712,7 @@ nsNativeThemeGTK::GetMinimumWidgetSize(nsPresContext* aPresContext,
 }
 
 NS_IMETHODIMP
-nsNativeThemeGTK::WidgetStateChanged(nsIFrame* aFrame, uint8_t aWidgetType, 
+nsNativeThemeGTK::WidgetStateChanged(nsIFrame* aFrame, uint8_t aWidgetType,
                                      nsIAtom* aAttribute, bool* aShouldRepaint,
                                      const nsAttrValue* aOldValue)
 {
@@ -1775,7 +1779,7 @@ nsNativeThemeGTK::WidgetStateChanged(nsIFrame* aFrame, uint8_t aWidgetType,
     *aShouldRepaint = true;
   }
   else {
-    // Check the attribute to see if it's relevant.  
+    // Check the attribute to see if it's relevant.
     // disabled, checked, dlgtype, default, etc.
     *aShouldRepaint = false;
     if (aAttribute == nsGkAtoms::disabled ||
@@ -1943,10 +1947,10 @@ bool
 nsNativeThemeGTK::ThemeDrawsFocusForWidget(uint8_t aWidgetType)
 {
    if (aWidgetType == NS_THEME_MENULIST ||
-      aWidgetType == NS_THEME_BUTTON || 
+      aWidgetType == NS_THEME_BUTTON ||
       aWidgetType == NS_THEME_TREEHEADERCELL)
     return true;
-  
+
   return false;
 }
 
diff --git a/widget/gtk/nsScreenGtk.cpp b/widget/gtk/nsScreenGtk.cpp
index 61e6605b76b9..aca0a238b38b 100644
--- a/widget/gtk/nsScreenGtk.cpp
+++ b/widget/gtk/nsScreenGtk.cpp
@@ -50,7 +50,7 @@ nsScreenGtk :: GetRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth, int
   *outHeight = mRect.height;
 
   return NS_OK;
-  
+
 } // GetRect
 
 
@@ -63,7 +63,7 @@ nsScreenGtk :: GetAvailRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth
   *outHeight = mAvailRect.height;
 
   return NS_OK;
-  
+
 } // GetAvailRect
 
 gint
@@ -93,7 +93,7 @@ nsScreenGtk :: GetDPIScale()
   return dpiScale;
 }
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 {
   GdkVisual * visual = gdk_screen_get_system_visual(gdk_screen_get_default());
@@ -103,7 +103,7 @@ nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 
 } // GetPixelDepth
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetColorDepth(int32_t *aColorDepth)
 {
   return GetPixelDepth ( aColorDepth );
@@ -130,6 +130,8 @@ nsScreenGtk :: Init (GdkWindow *aRootWindow)
   // versions of GDK predating the GdkScreen object.  See bug 256646.
   mAvailRect = mRect = nsIntRect(0, 0, width, height);
 
+  return; //TODO
+
 #ifdef MOZ_X11
   // We need to account for the taskbar, etc in the available rect.
   // See http://freedesktop.org/Standards/wm-spec/index.html#id2767771
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index d97b35002c56..8e86d0dfc409 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -5,6 +5,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include <assert.h>
 #include "nsWindow.h"
 
 #include "mozilla/ArrayUtils.h"
@@ -58,6 +59,10 @@
 #include <gtk/gtkprivate.h>
 #endif
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include "nsGkAtoms.h"
 
 #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
@@ -303,11 +308,14 @@ public:
 
     guint32 GetCurrentTime() const
     {
-        return gdk_x11_get_server_time(mWindow);
+        //return gdk_x11_get_server_time(mWindow);
+        return g_get_monotonic_time()/1000;
     }
 
     void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow)
     {
+        return; // TODO
+
         // Check for in-flight request
         if (!mAsyncUpdateStart.IsNull()) {
             return;
@@ -326,6 +334,8 @@ public:
     gboolean PropertyNotifyHandler(GtkWidget* aWidget,
                                    GdkEventProperty* aEvent)
     {
+        return FALSE;
+
         if (aEvent->atom !=
             gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
             return FALSE;
@@ -458,6 +468,9 @@ nsWindow::nsWindow()
     mXDepth   = 0;
 #endif /* MOZ_X11 */
     mPluginType          = PluginType_NONE;
+#ifdef GDK_WINDOWING_WAYLAND
+    mWaylandSurface = nullptr;
+#endif
 
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = true;
@@ -1390,6 +1403,9 @@ SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
 /* static */ guint32
 nsWindow::GetLastUserInputTime()
 {
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default()))
+        return sLastUserInputTime;
+
     // gdk_x11_display_get_user_time tracks button and key presses,
     // DESKTOP_STARTUP_ID used to start the app, drop events from external
     // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
@@ -1740,12 +1756,17 @@ nsWindow::GetNativeData(uint32_t aDataType)
         return (void*)mPluginNativeWindow->window;
 
     case NS_NATIVE_DISPLAY: {
-#ifdef MOZ_X11
+#if defined(MOZ_X11)
         GdkDisplay* gdkDisplay = gdk_display_get_default();
         if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
           return GDK_DISPLAY_XDISPLAY(gdkDisplay);
         }
 #endif /* MOZ_X11 */
+#if defined(GDK_WINDOWING_WAYLAND)
+        if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
+          return gdk_wayland_display_get_wl_display(gdkDisplay);
+        }
+#endif
         return nullptr;
     }
     case NS_NATIVE_SHELLWIDGET:
@@ -1769,10 +1790,15 @@ nsWindow::GetNativeData(uint32_t aDataType)
     }
     case NS_NATIVE_OPENGL_CONTEXT:
       return nullptr;
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     case NS_NATIVE_COMPOSITOR_DISPLAY:
-        return gfxPlatformGtk::GetPlatform()->GetCompositorDisplay();
-#endif // MOZ_X11
+        if (mIsX11Display)
+          return gfxPlatformGtk::GetPlatform()->GetXCompositorDisplay();
+        else
+          return gfxPlatformGtk::GetPlatform()->GetWaylandCompositorDisplay();
+    case NS_NATIVE_COMPOSITOR_DISPLAY_X11:
+        return (void *)mIsX11Display;
+#endif // MOZ_X11 || GDK_WINDOWING_WAYLAND
     default:
         NS_WARNING("nsWindow::GetNativeData called with bad value");
         return nullptr;
@@ -2139,6 +2165,12 @@ nsWindow::OnExposeEvent(cairo_t *cr)
     if (!listener)
         return FALSE;
 
+#ifdef GDK_WINDOWING_WAYLAND
+    // We don't have any Wayland surface to paint to
+    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
+        return FALSE;
+#endif
+
     LayoutDeviceIntRegion exposeRegion;
 #if (MOZ_WIDGET_GTK == 2)
     if (!ExtractExposeRegion(exposeRegion, aEvent)) {
@@ -3764,7 +3796,10 @@ nsWindow::Create(nsIWidget* aParent,
         // Create a container to hold child windows and child GtkWidgets.
         GtkWidget *container = moz_container_new();
         mContainer = MOZ_CONTAINER(container);
-
+        // We use mContainer to draw on Wayland
+        if (!mIsX11Display) {
+            shellHasCSD = true;
+        }
 #if (MOZ_WIDGET_GTK == 3)
         // "csd" style is set when widget is realized so we need to call
         // it explicitly now.
@@ -3773,6 +3808,8 @@ nsWindow::Create(nsIWidget* aParent,
         // We can't draw directly to top-level window when client side
         // decorations are enabled. We use container with GdkWindow instead.
         GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+
+        // Always draw to mozcontainer on Wayland
         shellHasCSD = gtk_style_context_has_class(style, "csd");
 #endif
         if (!shellHasCSD) {
@@ -3794,6 +3831,12 @@ nsWindow::Create(nsIWidget* aParent,
 
         // the drawing window
         mGdkWindow = gtk_widget_get_window(eventWidget);
+#if defined(GDK_WINDOWING_WAYLAND)
+        wl_surface *waylandSurface = moz_container_get_wl_surface(
+                                          MOZ_CONTAINER(container));
+        g_object_set_data(G_OBJECT(mGdkWindow), "WAYLAND_SURFACE",
+                          waylandSurface);
+#endif
 
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
@@ -4021,6 +4064,13 @@ nsWindow::Create(nsIWidget* aParent,
 
       mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    else {
+      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+      mSurfaceProvider.Initialize(mWaylandDisplay, mWaylandSurface);
+    }
+#endif
 #endif
 
     return NS_OK;
@@ -4705,14 +4755,10 @@ nsWindow::GrabPointer(guint32 aTime)
     if (!mGdkWindow)
         return;
 
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
     gint retval;
-    retval = gdk_pointer_grab(mGdkWindow, TRUE,
-                              (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
-                                             GDK_BUTTON_RELEASE_MASK |
-                                             GDK_ENTER_NOTIFY_MASK |
-                                             GDK_LEAVE_NOTIFY_MASK |
-                                             GDK_POINTER_MOTION_MASK),
-                              (GdkWindow *)nullptr, nullptr, aTime);
+    retval = gdk_seat_grab(gdkSeat, mGdkWindow, GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                           nullptr, nullptr, nullptr, nullptr);
 
     if (retval == GDK_GRAB_NOT_VIEWABLE) {
         LOG(("GrabPointer: window not viewable; will retry\n"));
@@ -4736,7 +4782,8 @@ nsWindow::ReleaseGrabs(void)
     LOG(("ReleaseGrabs\n"));
 
     mRetryPointerGrab = false;
-    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gdk_seat_ungrab(gdkSeat);
 }
 
 GtkWidget *
@@ -7028,9 +7075,18 @@ nsWindow::RoundsWidgetCoordinatesTo()
 void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData)
 {
   #ifdef MOZ_X11
-  *aInitData = mozilla::widget::CompositorWidgetInitData(
+    if (mIsX11Display) {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
                                   mXWindow,
                                   nsCString(XDisplayString(mXDisplay)),
                                   GetClientSize());
+  #ifdef GDK_WINDOWING_WAYLAND
+  } else {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
+                                  (uintptr_t)mWaylandSurface,
+                                  nullptr,
+                                  GetClientSize());
+  }
+  #endif
   #endif
 }
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index 49a8d4baf380..c1398735882a 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -346,9 +346,13 @@ public:
                                                 nsIObserver* aObserver) override;
 #endif
 
+    bool     IsX11Display() { return mIsX11Display; }
 #ifdef MOZ_X11
     Display* XDisplay() { return mXDisplay; }
 #endif
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* WaylandDisplay() { return mWaylandDisplay; }
+#endif
     virtual void GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData) override;
 
     // HiDPI scale conversion
@@ -462,6 +466,10 @@ private:
     Window              mXWindow;
     Visual*             mXVisual;
     int                 mXDepth;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display*         mWaylandDisplay;
+    wl_surface*         mWaylandSurface;
+#endif
     mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 #endif
 
diff --git a/widget/gtk/os-compatibility.c b/widget/gtk/os-compatibility.c
new file mode 100644
index 000000000000..3439075ad752
--- /dev/null
+++ b/widget/gtk/os-compatibility.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+* This file is a part of Weston project,
+* https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.c
+*/
+
+#include "mozilla-config.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/epoll.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "os-compatibility.h"
+
+int
+os_fd_set_cloexec(int fd)
+{
+	long flags;
+
+	if (fd == -1)
+		return -1;
+
+	flags = fcntl(fd, F_GETFD);
+	if (flags == -1)
+		return -1;
+
+	if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+		return -1;
+
+	return 0;
+}
+
+static int
+set_cloexec_or_close(int fd)
+{
+	if (os_fd_set_cloexec(fd) != 0) {
+		close(fd);
+		return -1;
+	}
+	return fd;
+}
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv)
+{
+	int ret;
+
+#ifdef SOCK_CLOEXEC
+	ret = socketpair(domain, type | SOCK_CLOEXEC, protocol, sv);
+	if (ret == 0 || errno != EINVAL)
+		return ret;
+#endif
+
+	ret = socketpair(domain, type, protocol, sv);
+	if (ret < 0)
+		return ret;
+
+	sv[0] = set_cloexec_or_close(sv[0]);
+	sv[1] = set_cloexec_or_close(sv[1]);
+
+	if (sv[0] != -1 && sv[1] != -1)
+		return 0;
+
+	close(sv[0]);
+	close(sv[1]);
+	return -1;
+}
+
+int
+os_epoll_create_cloexec(void)
+{
+	int fd;
+
+#ifdef EPOLL_CLOEXEC
+	fd = epoll_create1(EPOLL_CLOEXEC);
+	if (fd >= 0)
+		return fd;
+	if (errno != EINVAL)
+		return -1;
+#endif
+
+	fd = epoll_create(1);
+	return set_cloexec_or_close(fd);
+}
+
+static int
+create_tmpfile_cloexec(char *tmpname)
+{
+	int fd;
+
+#ifdef HAVE_MKOSTEMP
+	fd = mkostemp(tmpname, O_CLOEXEC);
+	if (fd >= 0)
+		unlink(tmpname);
+#else
+	fd = mkstemp(tmpname);
+	if (fd >= 0) {
+		fd = set_cloexec_or_close(fd);
+		unlink(tmpname);
+	}
+#endif
+
+	return fd;
+}
+
+/*
+ * Create a new, unique, anonymous file of the given size, and
+ * return the file descriptor for it. The file descriptor is set
+ * CLOEXEC. The file is immediately suitable for mmap()'ing
+ * the given size at offset zero.
+ *
+ * The file should not have a permanent backing store like a disk,
+ * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
+ *
+ * The file name is deleted from the file system.
+ *
+ * The file is suitable for buffer sharing between processes by
+ * transmitting the file descriptor over Unix sockets using the
+ * SCM_RIGHTS methods.
+ *
+ * If the C library implements posix_fallocate(), it is used to
+ * guarantee that disk space is available for the file at the
+ * given size. If disk space is insufficent, errno is set to ENOSPC.
+ * If posix_fallocate() is not supported, program may receive
+ * SIGBUS on accessing mmap()'ed file contents instead.
+ */
+int
+os_create_anonymous_file(off_t size)
+{
+	static const char template[] = "/weston-shared-XXXXXX";
+	const char *path;
+	char *name;
+	int fd;
+	int ret;
+
+	path = getenv("XDG_RUNTIME_DIR");
+	if (!path) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	name = malloc(strlen(path) + sizeof(template));
+	if (!name)
+		return -1;
+
+	strcpy(name, path);
+	strcat(name, template);
+
+	fd = create_tmpfile_cloexec(name);
+
+	free(name);
+
+	if (fd < 0)
+		return -1;
+
+#ifdef HAVE_POSIX_FALLOCATE
+	ret = posix_fallocate(fd, 0, size);
+	if (ret != 0) {
+		close(fd);
+		errno = ret;
+		return -1;
+	}
+#else
+	ret = ftruncate(fd, size);
+	if (ret < 0) {
+		close(fd);
+		return -1;
+	}
+#endif
+
+	return fd;
+}
diff --git a/widget/gtk/os-compatibility.h b/widget/gtk/os-compatibility.h
new file mode 100644
index 000000000000..5dbd3b616104
--- /dev/null
+++ b/widget/gtk/os-compatibility.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+ /*
+  * This file is a part of Weston project,
+  * https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.h
+  */
+
+#ifndef OS_COMPATIBILITY_H
+#define OS_COMPATIBILITY_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+int
+os_fd_set_cloexec(int fd);
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv);
+
+int
+os_epoll_create_cloexec(void);
+
+int
+os_create_anonymous_file(off_t size);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* OS_COMPATIBILITY_H */
diff --git a/widget/nsIWidget.h b/widget/nsIWidget.h
index 2d14cc107f11..beea447982a4 100644
--- a/widget/nsIWidget.h
+++ b/widget/nsIWidget.h
@@ -132,6 +132,8 @@ typedef void* nsNativeWidget;
 #define NS_NATIVE_PLUGIN_OBJECT_PTR    104
 #ifdef MOZ_X11
 #define NS_NATIVE_COMPOSITOR_DISPLAY   105
+// Return true the compositor display is X11
+#define NS_NATIVE_COMPOSITOR_DISPLAY_X11 106
 #endif // MOZ_X11
 #endif
 #ifdef MOZ_WIDGET_ANDROID
-- 
2.11.0

